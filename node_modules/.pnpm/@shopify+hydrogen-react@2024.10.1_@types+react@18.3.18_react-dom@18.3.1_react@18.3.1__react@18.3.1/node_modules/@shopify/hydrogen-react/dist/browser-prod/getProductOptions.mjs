import { isOptionValueCombinationInEncodedVariant } from "./optionValueDecoder.mjs";
function mapProductOptions(options) {
  return options.map((option) => {
    return Object.assign(
      {},
      ...(option == null ? void 0 : option.optionValues) ? option.optionValues.map((value, index) => {
        return { [value.name]: index };
      }) : []
    );
  });
}
function mapSelectedProductOptionToObject(options) {
  return Object.assign(
    {},
    ...options.map((key) => {
      return { [key.name]: key.value };
    })
  );
}
function mapSelectedProductOptionToObjectAsString(options) {
  return JSON.stringify(mapSelectedProductOptionToObject(options));
}
function encodeSelectedProductOptionAsKey(selectedOption, productOptionMappings) {
  if (Array.isArray(selectedOption)) {
    return JSON.stringify(
      selectedOption.map((key, index) => {
        return productOptionMappings[index][key.value];
      })
    );
  } else {
    return JSON.stringify(
      Object.keys(selectedOption).map((key, index) => {
        return productOptionMappings[index][selectedOption[key]];
      })
    );
  }
}
function mapVariants(variants, productOptionMappings) {
  return Object.assign(
    {},
    ...variants.map((variant) => {
      const variantKey = encodeSelectedProductOptionAsKey(
        variant.selectedOptions || [],
        productOptionMappings
      );
      return { [variantKey]: variant };
    })
  );
}
const PRODUCT_INPUTS = [
  "options",
  "selectedOrFirstAvailableVariant",
  "adjacentVariants"
];
const PRODUCT_INPUTS_EXTRA = [
  "handle",
  "encodedVariantExistence",
  "encodedVariantAvailability"
];
function logErrorAndReturnFalse(key) {
  console.error(
    `[h2:error:getProductOptions] product.${key} is missing. Make sure you query for this field from the Storefront API.`
  );
  return false;
}
function checkProductParam(product, checkAll = false) {
  var _a;
  let validParam = true;
  const productKeys = Object.keys(product);
  (checkAll ? [...PRODUCT_INPUTS, ...PRODUCT_INPUTS_EXTRA] : PRODUCT_INPUTS).forEach((key) => {
    if (!productKeys.includes(key)) {
      validParam = logErrorAndReturnFalse(key);
    }
  });
  if (product.options) {
    const firstOption = product == null ? void 0 : product.options[0];
    if (checkAll && !(firstOption == null ? void 0 : firstOption.name)) {
      validParam = logErrorAndReturnFalse("options.name");
    }
    if ((_a = product == null ? void 0 : product.options[0]) == null ? void 0 : _a.optionValues) {
      const firstOptionValues = product.options[0].optionValues[0];
      if (checkAll && !(firstOptionValues == null ? void 0 : firstOptionValues.name)) {
        validParam = logErrorAndReturnFalse("options.optionValues.name");
      }
      if (firstOptionValues == null ? void 0 : firstOptionValues.firstSelectableVariant) {
        validParam = checkProductVariantParam(
          firstOptionValues.firstSelectableVariant,
          "options.optionValues.firstSelectableVariant",
          validParam,
          checkAll
        );
      } else {
        validParam = logErrorAndReturnFalse(
          "options.optionValues.firstSelectableVariant"
        );
      }
    } else {
      validParam = logErrorAndReturnFalse("options.optionValues");
    }
  }
  if (product.selectedOrFirstAvailableVariant) {
    validParam = checkProductVariantParam(
      product.selectedOrFirstAvailableVariant,
      "selectedOrFirstAvailableVariant",
      validParam,
      checkAll
    );
  }
  if (!!product.adjacentVariants && product.adjacentVariants[0]) {
    validParam = checkProductVariantParam(
      product.adjacentVariants[0],
      "adjacentVariants",
      validParam,
      checkAll
    );
  }
  return validParam ? product : {};
}
function checkProductVariantParam(variant, key, currentValidParamState, checkAll) {
  var _a;
  let validParam = currentValidParamState;
  if (checkAll && !((_a = variant.product) == null ? void 0 : _a.handle)) {
    validParam = logErrorAndReturnFalse(`${key}.product.handle`);
  }
  if (variant.selectedOptions) {
    const firstSelectedOption = variant.selectedOptions[0];
    if (!(firstSelectedOption == null ? void 0 : firstSelectedOption.name)) {
      validParam = logErrorAndReturnFalse(`${key}.selectedOptions.name`);
    }
    if (!(firstSelectedOption == null ? void 0 : firstSelectedOption.value)) {
      validParam = logErrorAndReturnFalse(`${key}.selectedOptions.value`);
    }
  } else {
    validParam = logErrorAndReturnFalse(`${key}.selectedOptions`);
  }
  return validParam;
}
function getAdjacentAndFirstAvailableVariants(product) {
  const checkedProduct = checkProductParam(product);
  if (!checkedProduct.options)
    return [];
  const availableVariants = {};
  checkedProduct.options.map((option) => {
    var _a;
    (_a = option.optionValues) == null ? void 0 : _a.map((value) => {
      if (value.firstSelectableVariant) {
        const variantKey = mapSelectedProductOptionToObjectAsString(
          value.firstSelectableVariant.selectedOptions
        );
        availableVariants[variantKey] = value.firstSelectableVariant;
      }
    });
  });
  checkedProduct.adjacentVariants.map((variant) => {
    const variantKey = mapSelectedProductOptionToObjectAsString(
      variant.selectedOptions
    );
    availableVariants[variantKey] = variant;
  });
  const selectedVariant = checkedProduct.selectedOrFirstAvailableVariant;
  if (selectedVariant) {
    const variantKey = mapSelectedProductOptionToObjectAsString(
      selectedVariant.selectedOptions
    );
    availableVariants[variantKey] = selectedVariant;
  }
  return Object.values(availableVariants);
}
function getProductOptions(product) {
  const checkedProduct = checkProductParam(product, true);
  if (!checkedProduct.options)
    return [];
  const {
    options,
    selectedOrFirstAvailableVariant: selectedVariant,
    adjacentVariants,
    encodedVariantExistence,
    encodedVariantAvailability,
    handle: productHandle
  } = checkedProduct;
  const productOptionMappings = mapProductOptions(options);
  const variants = mapVariants(
    selectedVariant ? [selectedVariant, ...adjacentVariants] : adjacentVariants,
    productOptionMappings
  );
  const selectedOptions = mapSelectedProductOptionToObject(
    selectedVariant ? selectedVariant.selectedOptions : []
  );
  const productOptions = options.map((option, optionIndex) => {
    return {
      ...option,
      optionValues: option.optionValues.map((value) => {
        var _a;
        const targetOptionParams = { ...selectedOptions };
        targetOptionParams[option.name] = value.name;
        const targetKey = encodeSelectedProductOptionAsKey(
          targetOptionParams || [],
          productOptionMappings
        );
        const topDownKey = JSON.parse(targetKey).slice(
          0,
          optionIndex + 1
        );
        const exists = isOptionValueCombinationInEncodedVariant(
          topDownKey,
          encodedVariantExistence || ""
        );
        const available = isOptionValueCombinationInEncodedVariant(
          topDownKey,
          encodedVariantAvailability || ""
        );
        const variant = variants[targetKey] || value.firstSelectableVariant;
        const variantOptionParam = mapSelectedProductOptionToObject(
          variant.selectedOptions || []
        );
        const searchParams = new URLSearchParams(variantOptionParam);
        const handle = (_a = variant == null ? void 0 : variant.product) == null ? void 0 : _a.handle;
        return {
          ...value,
          variant,
          handle,
          variantUriQuery: searchParams.toString(),
          selected: selectedOptions[option.name] === value.name,
          exists,
          available,
          isDifferentProduct: handle !== productHandle
        };
      })
    };
  });
  return productOptions;
}
export {
  checkProductParam,
  getAdjacentAndFirstAvailableVariants,
  getProductOptions,
  mapSelectedProductOptionToObject
};
//# sourceMappingURL=getProductOptions.mjs.map
