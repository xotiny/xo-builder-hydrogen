{"version":3,"file":"CartProvider.mjs","sources":["../../src/CartProvider.tsx"],"sourcesContent":["import {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  useTransition,\n  createContext,\n  useContext,\n} from 'react';\nimport {\n  AttributeInput,\n  CartBuyerIdentityInput,\n  CartInput,\n  CartLineInput,\n  CartLineUpdateInput,\n  CountryCode,\n  LanguageCode,\n  Cart as CartType,\n  MutationCartNoteUpdateArgs,\n} from './storefront-api-types.js';\nimport {\n  BuyerIdentityUpdateEvent,\n  CartMachineContext,\n  CartMachineEvent,\n  CartMachineTypeState,\n  CartWithActions,\n  CartWithActionsDocs,\n} from './cart-types.js';\nimport {useCartAPIStateMachine} from './useCartAPIStateMachine.js';\nimport {CART_ID_STORAGE_KEY} from './cart-constants.js';\nimport {PartialDeep} from 'type-fest';\nimport {defaultCartFragment} from './cart-queries.js';\nimport {useShop} from './ShopifyProvider.js';\n\nexport const CartContext = createContext<CartWithActions | null>(null);\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ntype UseCartDocs = () => CartWithActionsDocs;\n\n/**\n * The `useCart` hook provides access to the cart object. It must be a descendent of a `CartProvider` component.\n */\nexport function useCart(): CartWithActions {\n  const context = useContext(CartContext);\n\n  if (!context) {\n    throw new Error('Expected a Cart Context, but no Cart Context was found');\n  }\n\n  return context;\n}\n\ntype CartProviderProps = {\n  /** Any `ReactNode` elements. */\n  children: React.ReactNode;\n  /**  Maximum number of cart lines to fetch. Defaults to 250 cart lines. */\n  numCartLines?: number;\n  /** A callback that is invoked when the process to create a cart begins, but before the cart is created in the Storefront API. */\n  onCreate?: () => void;\n  /** A callback that is invoked when the process to add a line item to the cart begins, but before the line item is added to the Storefront API. */\n  onLineAdd?: () => void;\n  /** A callback that is invoked when the process to remove a line item to the cart begins, but before the line item is removed from the Storefront API. */\n  onLineRemove?: () => void;\n  /** A callback that is invoked when the process to update a line item in the cart begins, but before the line item is updated in the Storefront API. */\n  onLineUpdate?: () => void;\n  /** A callback that is invoked when the process to add or update a note in the cart begins, but before the note is added or updated in the Storefront API. */\n  onNoteUpdate?: () => void;\n  /** A callback that is invoked when the process to update the buyer identity begins, but before the buyer identity is updated in the Storefront API. */\n  onBuyerIdentityUpdate?: () => void;\n  /** A callback that is invoked when the process to update the cart attributes begins, but before the attributes are updated in the Storefront API. */\n  onAttributesUpdate?: () => void;\n  /** A callback that is invoked when the process to update the cart discount codes begins, but before the discount codes are updated in the Storefront API. */\n  onDiscountCodesUpdate?: () => void;\n  /** A callback that is invoked when the process to create a cart completes */\n  onCreateComplete?: () => void;\n  /** A callback that is invoked when the process to add a line item to the cart completes */\n  onLineAddComplete?: () => void;\n  /** A callback that is invoked when the process to remove a line item to the cart completes */\n  onLineRemoveComplete?: () => void;\n  /** A callback that is invoked when the process to update a line item in the cart completes */\n  onLineUpdateComplete?: () => void;\n  /** A callback that is invoked when the process to add or update a note in the cart completes */\n  onNoteUpdateComplete?: () => void;\n  /** A callback that is invoked when the process to update the buyer identity completes */\n  onBuyerIdentityUpdateComplete?: () => void;\n  /** A callback that is invoked when the process to update the cart attributes completes */\n  onAttributesUpdateComplete?: () => void;\n  /** A callback that is invoked when the process to update the cart discount codes completes */\n  onDiscountCodesUpdateComplete?: () => void;\n  /** An object with fields that correspond to the Storefront API's [Cart object](https://shopify.dev/api/storefront/2024-10/objects/cart). */\n  data?: PartialDeep<CartType, {recurseIntoArrays: true}>;\n  /** A fragment used to query the Storefront API's [Cart object](https://shopify.dev/api/storefront/2024-10/objects/cart) for all queries and mutations. A default value is used if no argument is provided. */\n  cartFragment?: string;\n  /** A customer access token that's accessible on the server if there's a customer login. */\n  customerAccessToken?: CartBuyerIdentityInput['customerAccessToken'];\n  /** The ISO country code for i18n. */\n  countryCode?: CountryCode;\n  /** The ISO language code for i18n. */\n  languageCode?: LanguageCode;\n};\n\n/**\n * The `CartProvider` component synchronizes the state of the Storefront API Cart and a customer's cart,\n * and allows you to more easily manipulate the cart by adding, removing, and updating it.\n * It could be placed at the root of your app so that your whole app is able to use the `useCart()` hook anywhere.\n *\n * There are props that trigger when a call to the Storefront API is made, such as `onLineAdd={}` when a line is added to the cart.\n * There are also props that trigger when a call to the Storefront API is completed, such as `onLineAddComplete={}` when the fetch request for adding a line to the cart completes.\n *\n * The `CartProvider` component must be a descendant of the `ShopifyProvider` component.\n */\nexport function CartProvider({\n  children,\n  numCartLines,\n  onCreate,\n  onLineAdd,\n  onLineRemove,\n  onLineUpdate,\n  onNoteUpdate,\n  onBuyerIdentityUpdate,\n  onAttributesUpdate,\n  onDiscountCodesUpdate,\n  onCreateComplete,\n  onLineAddComplete,\n  onLineRemoveComplete,\n  onLineUpdateComplete,\n  onNoteUpdateComplete,\n  onBuyerIdentityUpdateComplete,\n  onAttributesUpdateComplete,\n  onDiscountCodesUpdateComplete,\n  data: cart,\n  cartFragment = defaultCartFragment,\n  customerAccessToken,\n  countryCode,\n  languageCode,\n}: CartProviderProps): JSX.Element {\n  const shop = useShop();\n\n  if (!shop)\n    throw new Error(\n      '<CartProvider> needs to be a descendant of <ShopifyProvider>',\n    );\n\n  countryCode = (\n    (countryCode as string) ??\n    shop.countryIsoCode ??\n    'US'\n  ).toUpperCase() as CountryCode;\n\n  languageCode = (\n    (languageCode as string) ??\n    shop.languageIsoCode ??\n    'EN'\n  ).toUpperCase() as LanguageCode;\n\n  if (countryCode) countryCode = countryCode.toUpperCase() as CountryCode;\n\n  const [prevCountryCode, setPrevCountryCode] = useState(countryCode);\n  const [prevCustomerAccessToken, setPrevCustomerAccessToken] =\n    useState(customerAccessToken);\n  const customerOverridesCountryCode = useRef(false);\n\n  if (\n    prevCountryCode !== countryCode ||\n    prevCustomerAccessToken !== customerAccessToken\n  ) {\n    setPrevCountryCode(countryCode);\n    setPrevCustomerAccessToken(customerAccessToken);\n    customerOverridesCountryCode.current = false;\n  }\n\n  const [cartState, cartSend] = useCartAPIStateMachine({\n    numCartLines,\n    data: cart,\n    cartFragment,\n    countryCode,\n    languageCode,\n    onCartActionEntry(_, event) {\n      try {\n        switch (event.type) {\n          case 'CART_CREATE':\n            return onCreate?.();\n          case 'CARTLINE_ADD':\n            return onLineAdd?.();\n          case 'CARTLINE_REMOVE':\n            return onLineRemove?.();\n          case 'CARTLINE_UPDATE':\n            return onLineUpdate?.();\n          case 'NOTE_UPDATE':\n            return onNoteUpdate?.();\n          case 'BUYER_IDENTITY_UPDATE':\n            return onBuyerIdentityUpdate?.();\n          case 'CART_ATTRIBUTES_UPDATE':\n            return onAttributesUpdate?.();\n          case 'DISCOUNT_CODES_UPDATE':\n            return onDiscountCodesUpdate?.();\n        }\n      } catch (error) {\n        console.error('Cart entry action failed', error);\n      }\n    },\n    onCartActionOptimisticUI(context, event) {\n      if (!context.cart) return {...context};\n      switch (event.type) {\n        case 'CARTLINE_REMOVE':\n          return {\n            ...context,\n            cart: {\n              ...context.cart,\n              lines: context?.cart?.lines?.filter(\n                (line) => line?.id && !event.payload.lines.includes(line?.id),\n              ),\n            },\n          };\n        case 'CARTLINE_UPDATE':\n          return {\n            ...context,\n            cart: {\n              ...context.cart,\n              lines: context?.cart?.lines?.map((line) => {\n                const updatedLine = event.payload.lines.find(\n                  ({id}) => id === line?.id,\n                );\n\n                if (updatedLine && updatedLine.quantity) {\n                  return {\n                    ...line,\n                    quantity: updatedLine.quantity,\n                  };\n                }\n\n                return line;\n              }),\n            },\n          };\n      }\n      return {...context};\n    },\n    onCartActionComplete(context, event) {\n      const cartActionEvent = event.payload.cartActionEvent;\n      try {\n        switch (event.type) {\n          case 'RESOLVE':\n            switch (cartActionEvent.type) {\n              case 'CART_CREATE':\n                return onCreateComplete?.();\n              case 'CARTLINE_ADD':\n                return onLineAddComplete?.();\n              case 'CARTLINE_REMOVE':\n                return onLineRemoveComplete?.();\n              case 'CARTLINE_UPDATE':\n                return onLineUpdateComplete?.();\n              case 'NOTE_UPDATE':\n                return onNoteUpdateComplete?.();\n              case 'BUYER_IDENTITY_UPDATE':\n                if (countryCodeNotUpdated(context, cartActionEvent)) {\n                  customerOverridesCountryCode.current = true;\n                }\n                return onBuyerIdentityUpdateComplete?.();\n              case 'CART_ATTRIBUTES_UPDATE':\n                return onAttributesUpdateComplete?.();\n              case 'DISCOUNT_CODES_UPDATE':\n                return onDiscountCodesUpdateComplete?.();\n            }\n        }\n      } catch (error) {\n        console.error('onCartActionComplete failed', error);\n      }\n    },\n  });\n\n  const cartReady = useRef(false);\n  const [isCartReady, setIsCartReady] = useState(false);\n  const cartCompleted = cartState.matches('cartCompleted');\n\n  const countryChanged =\n    (cartState.value === 'idle' ||\n      cartState.value === 'error' ||\n      cartState.value === 'cartCompleted') &&\n    countryCode !== cartState?.context?.cart?.buyerIdentity?.countryCode &&\n    !cartState.context.errors;\n\n  const fetchingFromStorage = useRef(false);\n\n  /**\n   * Initializes cart with priority in this order:\n   * 1. cart props\n   * 2. localStorage cartId\n   */\n  useEffect(() => {\n    if (!cartReady.current && !fetchingFromStorage.current) {\n      if (!cart && storageAvailable('localStorage')) {\n        fetchingFromStorage.current = true;\n        try {\n          const cartId = window.localStorage.getItem(CART_ID_STORAGE_KEY);\n          if (cartId) {\n            cartSend({type: 'CART_FETCH', payload: {cartId}});\n          }\n        } catch (error) {\n          console.warn('error fetching cartId');\n          console.warn(error);\n        }\n      }\n      cartReady.current = true;\n      // Providing a separate cart ready state variable to avoid re-renders in this logic while still being able to pass the reactive status through context.\n      setIsCartReady(true);\n    }\n  }, [cart, cartReady, cartSend]);\n\n  // Update cart country code if cart and props countryCode's as different\n  useEffect(() => {\n    if (!countryChanged || customerOverridesCountryCode.current) return;\n    cartSend({\n      type: 'BUYER_IDENTITY_UPDATE',\n      payload: {buyerIdentity: {countryCode, customerAccessToken}},\n    });\n  }, [\n    countryCode,\n    customerAccessToken,\n    countryChanged,\n    customerOverridesCountryCode,\n    cartSend,\n  ]);\n\n  // send cart events when ready\n  const onCartReadySend = useCallback(\n    (cartEvent: CartMachineEvent) => {\n      if (!cartReady.current) {\n        return console.warn(\"Cart isn't ready yet\");\n      }\n      cartSend(cartEvent);\n    },\n    [cartSend],\n  );\n\n  // save cart id to local storage\n  useEffect(() => {\n    if (cartState?.context?.cart?.id && storageAvailable('localStorage')) {\n      try {\n        window.localStorage.setItem(\n          CART_ID_STORAGE_KEY,\n          cartState.context.cart?.id,\n        );\n      } catch (error) {\n        console.warn('Failed to save cartId to localStorage', error);\n      }\n    }\n  }, [cartState?.context?.cart?.id]);\n\n  // delete cart from local storage if cart fetched has been completed\n  useEffect(() => {\n    if (cartCompleted && storageAvailable('localStorage')) {\n      try {\n        window.localStorage.removeItem(CART_ID_STORAGE_KEY);\n      } catch (error) {\n        console.warn('Failed to delete cartId from localStorage', error);\n      }\n    }\n  }, [cartCompleted]);\n\n  const cartCreate = useCallback(\n    (cartInput: CartInput) => {\n      if (countryCode && !cartInput.buyerIdentity?.countryCode) {\n        if (cartInput.buyerIdentity == null) {\n          cartInput.buyerIdentity = {};\n        }\n        cartInput.buyerIdentity.countryCode = countryCode;\n      }\n\n      if (\n        customerAccessToken &&\n        !cartInput.buyerIdentity?.customerAccessToken\n      ) {\n        if (cartInput.buyerIdentity == null) {\n          cartInput.buyerIdentity = {};\n        }\n        cartInput.buyerIdentity.customerAccessToken = customerAccessToken;\n      }\n      onCartReadySend({\n        type: 'CART_CREATE',\n        payload: cartInput,\n      });\n    },\n    [countryCode, customerAccessToken, onCartReadySend],\n  );\n\n  // Delays the cart state in the context if the page is hydrating\n  // preventing suspense boundary errors.\n  const cartDisplayState = useDelayedStateUntilHydration(cartState);\n\n  const cartContextValue = useMemo<CartWithActions>(() => {\n    return {\n      ...(cartDisplayState?.context?.cart ?? {lines: [], attributes: []}),\n      status: transposeStatus(cartDisplayState.value),\n      error: cartDisplayState?.context?.errors,\n      totalQuantity: cartDisplayState?.context?.cart?.totalQuantity ?? 0,\n      cartCreate,\n      cartReady: isCartReady,\n      linesAdd(lines: CartLineInput[]): void {\n        if (cartDisplayState?.context?.cart?.id) {\n          onCartReadySend({\n            type: 'CARTLINE_ADD',\n            payload: {lines},\n          });\n        } else {\n          cartCreate({lines});\n        }\n      },\n      linesRemove(lines: string[]): void {\n        onCartReadySend({\n          type: 'CARTLINE_REMOVE',\n          payload: {\n            lines,\n          },\n        });\n      },\n      linesUpdate(lines: CartLineUpdateInput[]): void {\n        onCartReadySend({\n          type: 'CARTLINE_UPDATE',\n          payload: {\n            lines,\n          },\n        });\n      },\n      noteUpdate(note: MutationCartNoteUpdateArgs['note']): void {\n        onCartReadySend({\n          type: 'NOTE_UPDATE',\n          payload: {\n            note,\n          },\n        });\n      },\n      buyerIdentityUpdate(buyerIdentity: CartBuyerIdentityInput): void {\n        onCartReadySend({\n          type: 'BUYER_IDENTITY_UPDATE',\n          payload: {\n            buyerIdentity,\n          },\n        });\n      },\n      cartAttributesUpdate(attributes: AttributeInput[]): void {\n        onCartReadySend({\n          type: 'CART_ATTRIBUTES_UPDATE',\n          payload: {\n            attributes,\n          },\n        });\n      },\n      discountCodesUpdate(discountCodes: string[]): void {\n        onCartReadySend({\n          type: 'DISCOUNT_CODES_UPDATE',\n          payload: {\n            discountCodes,\n          },\n        });\n      },\n      cartFragment,\n    };\n  }, [\n    cartCreate,\n    isCartReady,\n    cartDisplayState?.context?.cart,\n    cartDisplayState?.context?.errors,\n    cartDisplayState.value,\n    cartFragment,\n    onCartReadySend,\n  ]);\n\n  return (\n    <CartContext.Provider value={cartContextValue}>\n      {children}\n    </CartContext.Provider>\n  );\n}\n\nfunction transposeStatus(\n  status: CartMachineTypeState['value'],\n): CartWithActions['status'] {\n  switch (status) {\n    case 'uninitialized':\n    case 'initializationError':\n      return 'uninitialized';\n    case 'idle':\n    case 'cartCompleted':\n    case 'error':\n      return 'idle';\n    case 'cartFetching':\n      return 'fetching';\n    case 'cartCreating':\n      return 'creating';\n    case 'cartLineAdding':\n    case 'cartLineRemoving':\n    case 'cartLineUpdating':\n    case 'noteUpdating':\n    case 'buyerIdentityUpdating':\n    case 'cartAttributesUpdating':\n    case 'discountCodesUpdating':\n      return 'updating';\n  }\n}\n\n/**\n * Delays a state update until hydration finishes. Useful for preventing suspense boundaries errors when updating a context\n * @remarks this uses startTransition and waits for it to finish.\n */\nfunction useDelayedStateUntilHydration<T>(state: T): T {\n  const [isPending, startTransition] = useTransition();\n  const [delayedState, setDelayedState] = useState(state);\n\n  const firstTimePending = useRef(false);\n  if (isPending) {\n    firstTimePending.current = true;\n  }\n\n  const firstTimePendingFinished = useRef(false);\n  if (!isPending && firstTimePending.current) {\n    firstTimePendingFinished.current = true;\n  }\n\n  useEffect(() => {\n    startTransition(() => {\n      if (!firstTimePendingFinished.current) {\n        setDelayedState(state);\n      }\n    });\n  }, [state]);\n\n  const displayState = firstTimePendingFinished.current ? state : delayedState;\n\n  return displayState;\n}\n\n/**\n * Check for storage availability function obtained from\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API\n */\nexport function storageAvailable(\n  type: 'localStorage' | 'sessionStorage',\n): boolean {\n  let storage;\n  try {\n    storage = window[type];\n    const x = '__storage_test__';\n    storage.setItem(x, x);\n    storage.removeItem(x);\n    return true;\n  } catch (e) {\n    return !!(\n      e instanceof DOMException &&\n      // everything except Firefox\n      (e.code === 22 ||\n        // Firefox\n        e.code === 1014 ||\n        // test name field too, because code might not be present\n        // everything except Firefox\n        e.name === 'QuotaExceededError' ||\n        // Firefox\n        e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\n      // acknowledge QuotaExceededError only if there's something already stored\n      storage &&\n      storage.length !== 0\n    );\n  }\n}\n\nfunction countryCodeNotUpdated(\n  context: CartMachineContext,\n  event: BuyerIdentityUpdateEvent,\n): boolean {\n  return !!(\n    event.payload.buyerIdentity.countryCode &&\n    context.cart?.buyerIdentity?.countryCode !==\n      event.payload.buyerIdentity.countryCode\n  );\n}\n"],"names":["_b","_a","_d","_c"],"mappings":"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"}