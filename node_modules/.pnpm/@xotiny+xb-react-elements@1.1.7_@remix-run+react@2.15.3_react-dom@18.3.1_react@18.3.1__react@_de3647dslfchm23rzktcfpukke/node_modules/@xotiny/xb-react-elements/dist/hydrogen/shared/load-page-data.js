import { flattenConnection, getPaginationVariables, getSelectedProductOptions } from '@shopify/hydrogen';
import { CONFIG } from "../../config";
import { ARTICLE_QUERY } from "../graphql/article-query";
import { BLOG_QUERY } from "../graphql/blog-query";
import { COLLECTIONS_QUERY } from "../graphql/collections-query";
import { PRODUCT_QUERY } from "../graphql/product-query";
import { filterBy, getShopifySettings, hasCollectionListManualSetting } from "../utils/get-shopify-settings";
import { rootSettingsShort } from "../../root-settings-short";
import { getAllStyles } from "../../utils/get-all-styles";
import { getCssCode } from "../../utils/get-css-code";
import { generateGoogleFontUrl, getFonts } from "../../utils/get-fonts";
import { getModifiersCssVariables } from "../../utils/get-modifiers-css-variables";
import { getAppliedFilter, getSortValuesFromParam } from "../../utils/get-collection-filter";
import { getGlobalCssSettings, getGlobalJsSettings } from "../../utils/get-global-settings";
import { PAGE_QUERY } from '../graphql/page-query';
import { PRODUCT_RECOMMEDATION_QUERY } from '../graphql/product-recommendation-query';
import { PRODUCTS_QUERY } from '../graphql/products-query';
import { SHOP_QUERY } from '../graphql/shop-query';
import { COLLECTION_QUERY } from '../graphql/collection-query';
import { COLLECTION_FILTER_QUERY } from '../graphql/collection-filter-query';
import { COLLECTION_ALL_QUERY } from '../graphql/collection-all-query';
import { settings } from './setting-default';
// async function readHeader(pageType: string): Promise<LibraryEntity.Base> {
//   if (pageType === 'dev') {
//     return new Promise(res => {
//       res(header);
//     });
//   }
//   return new Promise(res => {
//     res(header);
//   });
//   // const res = await fetch('/header');
//   // const data = await res.json();
//   // return data;
// }
// async function readFooter(pageType: string): Promise<LibraryEntity.Base> {
//   if (pageType === 'dev') {
//     return new Promise(res => {
//       res(footer);
//     });
//   }
//   return new Promise(res => {
//     res(footer);
//   });
//   // const res = await fetch('/footer');
//   // const data = await res.json();
//   // return data;
// }
function getURL(pageType, id) {
    const assignId = id?.replace(/gid:\/\/shopify\/\w*\//g, '') ?? '';
    switch (pageType) {
        case 'home':
            return `${CONFIG.API.URL}${CONFIG.API.HOME}`;
        case 'product':
            return `${CONFIG.API.URL}${CONFIG.API.PRODUCT}?assignId=${assignId}`;
        case 'collection':
            const param = assignId ? `?assignId=${assignId}` : '';
            return `${CONFIG.API.URL}${CONFIG.API.COLLECTION}${param}`;
        case 'article':
            return `${CONFIG.API.URL}${CONFIG.API.ARTICLE}?assignId=${assignId}`;
        case 'regular':
            return `${CONFIG.API.URL}${CONFIG.API.PAGE}?assignId=${assignId}`;
        default:
            return CONFIG.dev.baseURL + CONFIG.dev.page;
    }
}
/**
 * Fetches page data from a specified URL based on the page type and ID.
 *
 * @param {LoaderFunctionArgs} context - The context object containing environment variables.
 * @param {string} pageType - The type of the page ('home', 'product', 'collection', 'article', 'regular').
 * @param {any} dataDefault - The default data to return if fetching fails or no data is available.
 * @param {string} id - The ID of the page to fetch data for.
 * @returns {Promise<any>} - A promise that resolves with the fetched page data or default data.
 * @throws Will throw an error if the fetch request fails.
 */
async function readPage({ context }, pageType, dataDefault, id) {
    const url = getURL(pageType, id);
    const { withCache, storefront } = context;
    const cacheKey = [url, `${pageType}-${id}`];
    try {
        const { data, response } = await withCache.fetch(url, {
            method: 'GET',
            headers: {
                Authorization: context.env.XO_BUILDER_TOKEN,
            },
        }, {
            cacheKey,
            cacheStrategy: storefront.CacheCustom({
                mode: 'must-revalidate, no-transform',
                maxAge: CONFIG.CACHE_MAX_AGE,
            }),
            shouldCacheResponse: () => true,
        });
        if (!response?.ok) {
            const error = await response.json();
            throw new Error(error.message);
        }
        const hasData = !!Object.keys(data?.payload?.entities).length;
        return hasData ? data?.payload : dataDefault;
    }
    catch (error) {
        console.error(error?.message);
        return dataDefault;
    }
}
/**
 * Fetches global settings data from the XoBuilder API.
 *
 * @returns {Promise<GlobalSettings>} - A promise that resolves with the fetched global settings data.
 * @throws Will throw an error if the fetch request fails.
 */
async function getGlobalSettings({ context }) {
    const { withCache, storefront } = context;
    const globalUrl = `${CONFIG.API.URL}${CONFIG.API.GLOBAL_SETTINGS}`;
    const cacheKey = [globalUrl, CONFIG.API.GLOBAL_SETTINGS];
    try {
        const { data, response } = await withCache.fetch(globalUrl, {
            method: 'GET',
            headers: {
                Authorization: context.env.XO_BUILDER_TOKEN,
            },
        }, {
            cacheKey,
            cacheStrategy: storefront.CacheCustom({
                mode: 'must-revalidate, no-transform',
                maxAge: CONFIG.CACHE_MAX_AGE,
            }),
            shouldCacheResponse: () => true,
        });
        if (!response?.ok) {
            const error = await response.json();
            throw new Error(error.message);
        }
        return data?.success
            ? {
                customCode: data?.payload?.application?.customCode,
                colors: data?.payload?.application?.page?.colors,
                layout: data?.payload?.application?.page?.layout,
                imageLoader: data?.payload?.application?.page?.imageLoader,
                placeholderImage: data?.payload?.application?.page?.placeholderImage,
            }
            : settings.globalSettings;
    }
    catch (error) {
        console.error(error?.message);
        return settings.globalSettings;
    }
}
/**
 * Fetches page settings data from the XoBuilder API by page ID.
 *
 * @param {string} pageId - The ID of the page to fetch data for.
 * @returns {Promise<PageSettings>} - A promise that resolves with the fetched page settings data.
 * @throws Will throw an error if the fetch request fails.
 */
async function getPageSettings({ context }, pageId) {
    const { withCache, storefront } = context;
    const pageSettingsUrl = `${CONFIG.API.URL}${CONFIG.API.PAGE_SETTINGS}${pageId}`;
    const cacheKey = [pageSettingsUrl, `${CONFIG.API.PAGE_SETTINGS}-${pageId}`];
    try {
        const { data, response } = await withCache.fetch(pageSettingsUrl, {
            method: 'GET',
            headers: {
                Authorization: context.env.XO_BUILDER_TOKEN,
            },
        }, {
            cacheKey,
            cacheStrategy: storefront.CacheCustom({
                mode: 'must-revalidate, no-transform',
                maxAge: CONFIG.CACHE_MAX_AGE,
            }),
            shouldCacheResponse: () => true,
        });
        if (!response?.ok) {
            const error = await response.json();
            throw new Error(error.message);
        }
        return data?.success ? data?.payload : settings.pageSettings;
    }
    catch (error) {
        console.error(error?.message);
        return settings.pageSettings;
    }
}
/**
 * Reads both global and page settings from the XoBuilder API.
 *
 * @param {string} pageId - The ID of the page to fetch data for.
 * @returns {Promise<{ globalSettings: GlobalSettings; pageSettings: PageSettings }>} - A promise that resolves with an object containing both global and page settings.
 */
async function readSettings(args, pageId) {
    const globalSettings = await getGlobalSettings(args);
    const pageSettings = await getPageSettings(args, pageId);
    return { globalSettings, pageSettings };
}
/**
 * Loads global and page-specific settings and generates CSS and JS code.
 *
 * @param {RootDataArgs} param0 - An object containing the page ID.
 * @returns {Promise<{ globalSettings: GlobalSettings; pageSettings: PageSettings; css: string; js: string }>}
 *   - A promise that resolves with an object containing global and page settings, as well as concatenated CSS and JS code.
 */
async function loadSettings({ args, pageId }) {
    const { globalSettings, pageSettings } = await readSettings(args, pageId);
    const globalJs = getGlobalJsSettings(globalSettings ?? {});
    const pageJs = getGlobalJsSettings(pageSettings ?? {});
    const globalCss = getGlobalCssSettings(globalSettings ?? {});
    const pageCss = getGlobalCssSettings(pageSettings ?? {});
    const pageCssJsEnabled = !!pageSettings;
    const css = pageCssJsEnabled ? globalCss + pageCss : globalCss;
    const js = pageCssJsEnabled ? globalJs + pageJs : pageJs;
    return {
        globalSettings,
        pageSettings,
        css,
        js,
    };
}
async function getCollection(shopifySettings, { context, request }) {
    const storefront = context.storefront;
    const collectionSettings = filterBy('collection', shopifySettings);
    return Object.fromEntries(await Promise.all(collectionSettings.map(item => {
        const handle = item.settings[CONFIG.shopifyFieldIds.collection].handle;
        const limit = item.settings[CONFIG.shopifyFieldIds.limit]?.value ?? 1;
        const paginationVariables = getPaginationVariables(request, {
            pageBy: limit,
        });
        const result = Promise.resolve(storefront.query(COLLECTION_QUERY, {
            variables: {
                handle,
                ...paginationVariables,
                country: storefront.i18n.country,
                language: storefront.i18n.language,
            },
            cache: storefront.CacheCustom({
                mode: 'must-revalidate, no-transform',
                maxAge: CONFIG.CACHE_MAX_AGE,
            }),
        })).then(resolvedValue => [item.id, resolvedValue.collection]);
        return result;
    })));
}
async function getCollectionDetail({ params, context, request }) {
    const { handle } = params;
    // const element = shopifySettings.find(item => item.elementId === 'collection-products');
    const isCollectionPage = (request.url.includes(`/collections/${handle}`) || decodeURI(request.url).includes(`/collections/${handle}`)) && !!handle;
    const limit = 8;
    if (isCollectionPage) {
        const storefront = context.storefront;
        const locale = storefront.i18n;
        const searchParams = new URL(request.url).searchParams;
        const { sortKey, reverse } = getSortValuesFromParam(searchParams.get('sort'), handle);
        const paginationVariables = getPaginationVariables(request, {
            pageBy: limit,
        });
        if (handle !== 'all') {
            const filters = [...searchParams.entries()].reduce((filters, [key, value]) => {
                if (key.startsWith(CONFIG.collectionPage.filterUrlPrefix)) {
                    const filterKey = key.substring(CONFIG.collectionPage.filterUrlPrefix.length);
                    if (filterKey != 'category') {
                        filters.push({
                            [filterKey]: JSON.parse(value),
                        });
                    }
                }
                return filters;
            }, []);
            const result = await Promise.resolve(storefront.query(COLLECTION_FILTER_QUERY, {
                variables: {
                    handle,
                    ...paginationVariables,
                    filters,
                    sortKey,
                    reverse,
                    country: storefront.i18n.country,
                    language: storefront.i18n.language,
                },
                cache: storefront.CacheCustom({
                    mode: 'must-revalidate, no-transform',
                    maxAge: CONFIG.CACHE_MAX_AGE,
                }),
            })).then(resolvedValue => {
                if (resolvedValue && resolvedValue?.collection) {
                    const allFilterValues = resolvedValue.collection?.products?.filters?.flatMap?.(filter => filter.values);
                    const appliedFilters = getAppliedFilter(filters, allFilterValues, locale);
                    return {
                        collection: resolvedValue.collection,
                        appliedFilters,
                        collections: flattenConnection(resolvedValue.collections),
                    };
                }
            });
            return result;
        }
        const result = Promise.resolve(storefront.query(COLLECTION_ALL_QUERY, {
            variables: {
                ...paginationVariables,
                sortKey,
                reverse,
                country: storefront.i18n.country,
                language: storefront.i18n.language,
            },
            cache: storefront.CacheCustom({
                mode: 'must-revalidate, no-transform',
                maxAge: CONFIG.CACHE_MAX_AGE,
            }),
        })).then(resolvedValue => {
            const data = {
                collection: {
                    id: '',
                    handle: 'all',
                    title: 'All',
                    descriptionHtml: 'All the store products',
                    description: 'All the store products',
                    products: resolvedValue.products,
                },
                appliedFilters: [],
                collections: resolvedValue?.collections ? flattenConnection(resolvedValue?.collections) : [],
            };
            return data;
        });
        return result;
    }
    return null;
}
async function getCollectionList(shopifySettings, { context, request }) {
    const storefront = context.storefront;
    const collectionListSettings = filterBy('collectionList', shopifySettings);
    return Object.fromEntries(await Promise.all(collectionListSettings.flatMap(item => {
        const list = item.settings[CONFIG.shopifyFieldIds.collectionList].map((item) => {
            const id = item.id.replace('gid://shopify/Collection/', '');
            return `(id:${id})`;
        });
        const limit = item.settings[CONFIG.shopifyFieldIds.limit]?.value;
        const query = hasCollectionListManualSetting(item.settings) ? list.join(' OR ') : '';
        const paginationVariables = getPaginationVariables(request, {
            pageBy: limit,
        });
        const result = Promise.resolve(storefront.query(COLLECTIONS_QUERY, {
            variables: {
                ...paginationVariables,
                query,
                country: storefront.i18n.country,
                language: storefront.i18n.language,
            },
            cache: storefront.CacheCustom({
                mode: 'must-revalidate, no-transform',
                maxAge: CONFIG.CACHE_MAX_AGE,
            }),
        })).then(resolvedValue => [item.id, resolvedValue]);
        return result;
    })));
}
async function getProductRecommendation(shopifySettings, { params, context }) {
    const storefront = context.storefront;
    const { handle: handleParam } = params;
    const productRecommendationSettings = filterBy('productRecommendation', shopifySettings);
    return Object.fromEntries(await Promise.all(productRecommendationSettings.flatMap(item => {
        const handle = item.settings.$product.handle || handleParam;
        const result = Promise.resolve(storefront.query(PRODUCT_RECOMMEDATION_QUERY, {
            variables: {
                productHandle: handle,
                country: storefront.i18n.country,
                language: storefront.i18n.language,
            },
            cache: storefront.CacheCustom({
                mode: 'must-revalidate, no-transform',
                maxAge: CONFIG.CACHE_MAX_AGE,
            }),
        })).then(resolvedValue => [item.id, resolvedValue]);
        return result;
    })));
}
async function getProducts(shopifySettings, { context, request }) {
    const storefront = context.storefront;
    const productListSettings = filterBy('productList', shopifySettings);
    return Object.fromEntries(await Promise.all(productListSettings.flatMap(item => {
        const limit = item.settings[CONFIG.shopifyFieldIds.limit]?.value;
        const paginationVariables = getPaginationVariables(request, {
            pageBy: limit,
        });
        const result = Promise.resolve(storefront.query(PRODUCTS_QUERY, {
            variables: {
                ...paginationVariables,
                country: storefront.i18n.country,
                language: storefront.i18n.language,
            },
            cache: storefront.CacheCustom({
                mode: 'must-revalidate, no-transform',
                maxAge: CONFIG.CACHE_MAX_AGE,
            }),
        })).then(resolvedValue => {
            const data = {
                products: [...resolvedValue.products.edges.map((item) => item.node)],
            };
            return [item.id, data];
        });
        return result;
    })));
}
async function getProduct(shopifySettings, { params, context, request }) {
    const { handle: handleParam } = params;
    const storefront = context.storefront;
    const productSettings = filterBy('product', shopifySettings);
    return Object.fromEntries(await Promise.all(productSettings.map(item => {
        const handle = item.settings[CONFIG.shopifyFieldIds.product].handle || handleParam;
        const result = Promise.resolve(storefront.query(PRODUCT_QUERY, {
            variables: {
                handle,
                selectedOptions: getSelectedProductOptions(request),
                country: storefront.i18n.country,
                language: storefront.i18n.language,
            },
            cache: storefront.CacheCustom({
                mode: 'must-revalidate, no-transform',
                maxAge: CONFIG.CACHE_MAX_AGE,
            }),
        })).then(resolvedValue => {
            if (resolvedValue?.product) {
                const firstVariant = resolvedValue.product.variants.nodes[0];
                const firstVariantIsDefault = Boolean(firstVariant.selectedOptions.find((option) => option.name === 'Title' && option.value === 'Default Title'));
                if (firstVariantIsDefault || !resolvedValue.product.selectedVariant) {
                    resolvedValue.product.selectedVariant = firstVariant;
                }
                return [item.id, resolvedValue?.product];
            }
            return [item.id, resolvedValue];
        });
        return result;
    })));
}
async function getProductDetail({ params, context, request }) {
    const { handle } = params;
    const isProductPage = (request.url.includes(`/products/${handle}`) || decodeURI(request.url).includes(`/products/${handle}`)) && !!handle;
    if (isProductPage) {
        const storefront = context.storefront;
        const result = await Promise.resolve(storefront.query(PRODUCT_QUERY, {
            variables: {
                handle,
                selectedOptions: getSelectedProductOptions(request),
                country: storefront.i18n.country,
                language: storefront.i18n.language,
            },
            cache: storefront.CacheCustom({
                mode: 'must-revalidate, no-transform',
                maxAge: CONFIG.CACHE_MAX_AGE,
            }),
        })).then(resolvedValue => {
            return resolvedValue.product;
        });
        return result;
    }
    return null;
}
async function getBlog(shopifySettings, { context, request }) {
    const storefront = context.storefront;
    const blogSettings = filterBy('blog', shopifySettings);
    return Object.fromEntries(await Promise.all(blogSettings.map(item => {
        const handle = item.settings[CONFIG.shopifyFieldIds.blog].handle;
        const limit = item.settings[CONFIG.shopifyFieldIds.limit]?.value ?? 1;
        const paginationVariables = getPaginationVariables(request, {
            pageBy: limit,
        });
        const result = Promise.resolve(storefront.query(BLOG_QUERY, {
            variables: {
                blogHandle: handle,
                ...paginationVariables,
                language: storefront.i18n.language,
            },
            cache: storefront.CacheCustom({
                mode: 'must-revalidate, no-transform',
                maxAge: CONFIG.CACHE_MAX_AGE,
            }),
        })).then(resolvedValue => [item.id, resolvedValue]);
        return result;
    })));
}
async function getArticle(shopifySettings, { context }) {
    const storefront = context.storefront;
    const productSettings = filterBy('article', shopifySettings);
    return Object.fromEntries(await Promise.all(productSettings.map(item => {
        const blogHandle = item.settings[CONFIG.shopifyFieldIds.article].blog_handle;
        const articleHandle = item.settings[CONFIG.shopifyFieldIds.article].handle;
        const result = Promise.resolve(storefront.query(ARTICLE_QUERY, {
            variables: {
                blogHandle,
                articleHandle,
                country: storefront.i18n.country,
                language: storefront.i18n.language,
            },
            cache: storefront.CacheCustom({
                mode: 'must-revalidate, no-transform',
                maxAge: CONFIG.CACHE_MAX_AGE,
            }),
        })).then(resolvedValue => {
            const data = resolvedValue?.blog?.articleByHandle;
            return [item.id, data];
        });
        return result;
    })));
}
async function getArticleDetail({ request, context, params }) {
    const { blogHandle, handle: articleHandle } = params;
    const storefront = context.storefront;
    const isArticlePage = (request.url.includes(`/blogs/${blogHandle}/${articleHandle}`) || decodeURI(request.url).includes(`/blogs/${blogHandle}/${articleHandle}`)) &&
        !!articleHandle &&
        !!blogHandle;
    if (isArticlePage) {
        const result = await Promise.resolve(storefront.query(ARTICLE_QUERY, {
            variables: {
                blogHandle,
                articleHandle,
                country: storefront.i18n.country,
                language: storefront.i18n.language,
            },
            cache: storefront.CacheCustom({
                mode: 'must-revalidate, no-transform',
                maxAge: CONFIG.CACHE_MAX_AGE,
            }),
        })).then(resolvedValue => resolvedValue.blog.articleByHandle);
        return result;
    }
    return null;
}
async function getPage({ request, context, params }) {
    const { handle } = params;
    const storefront = context.storefront;
    const isPage = (request.url.includes(`/pages/${handle}`) || decodeURI(request.url).includes(`/pages/${handle}`)) && !!handle;
    if (isPage) {
        const result = await Promise.resolve(storefront.query(PAGE_QUERY, {
            variables: {
                handle: params.handle,
                language: storefront.i18n.language,
            },
            cache: storefront.CacheCustom({
                mode: 'must-revalidate, no-transform',
                maxAge: CONFIG.CACHE_MAX_AGE,
            }),
        })).then(resolvedValue => resolvedValue.page);
        return result;
    }
    return null;
}
async function getShop({ context }) {
    const storefront = context.storefront;
    const result = await Promise.resolve(storefront.query(SHOP_QUERY, {
        cache: storefront.CacheCustom({
            mode: 'must-revalidate, no-transform',
            maxAge: CONFIG.CACHE_MAX_AGE,
        }),
    })).then(resolvedValue => {
        return resolvedValue.shop;
    });
    return result;
}
function getAssignId(pageType, productDetail, articleDetail, handle, collectionDetail) {
    switch (pageType) {
        case 'product':
            return productDetail?.id;
        case 'article':
            return articleDetail?.id;
        case 'collection':
            return collectionDetail?.id;
        case 'regular':
            return handle;
        default:
            return '';
    }
}
function cleanedObject(obj) {
    const result = Object.entries(obj).reduce((acc, [key, value]) => {
        if (value !== null && value !== undefined && value !== '') {
            acc[key] = value;
        }
        return acc;
    }, {});
    return result;
}
export async function loadPageData({ pageType, args, data }) {
    const { params } = args;
    const { handle } = params;
    const [productDetail, articleDetail, page, collectionDetail] = await Promise.all([
        getProductDetail(args),
        getArticleDetail(args),
        getPage(args),
        getCollectionDetail(args),
    ]);
    const id = getAssignId(pageType, productDetail, articleDetail, handle ?? '', collectionDetail);
    const [contentData] = await Promise.all([readPage(args, pageType, data, id)]);
    const pageId = contentData._id;
    const pageSettings = await loadSettings({ args, pageId });
    const pageData = {
        ...contentData,
        entities: {
            ...contentData.entities,
        },
        order: [...contentData.order],
    };
    const seo = {
        title: pageData?.configs?.seoTitle,
        titleTemplate: pageData?.configs?.seoTitle ?? pageData?.label,
        description: pageData?.configs?.seoDescription,
        media: pageData?.configs?.metaImage,
    };
    const metaData = cleanedObject(seo);
    const shopifySettings = getShopifySettings(pageData);
    const [collection, product, collectionList, blog, article, productRecommendation, productList, shop] = await Promise.all([
        getCollection(shopifySettings, args),
        getProduct(shopifySettings, args),
        getCollectionList(shopifySettings, args),
        getBlog(shopifySettings, args),
        getArticle(shopifySettings, args),
        getProductRecommendation(shopifySettings, args),
        getProducts(shopifySettings, args),
        getShop(args),
    ]);
    const fonts = getFonts({ currentElements: pageData.entities });
    const linkFonts = fonts
        ? fonts.filter(font => font.fontFamily).map(font => generateGoogleFontUrl({ family: font.fontFamily, variants: font.variants }))
        : [];
    const cssContent = getAllStyles(pageData.entities, rootSettingsShort).join('\n') +
        getCssCode(pageData.entities, rootSettingsShort) +
        getModifiersCssVariables(pageData.entities, rootSettingsShort).join('\n');
    return {
        pageData,
        cssContent,
        fonts: linkFonts,
        shopifyData: {
            collection,
            product,
            collectionList,
            blog,
            article,
            productRecommendation,
            productList,
            shop,
            productDetail,
            collectionDetail,
            articleDetail,
            page,
        },
        metaData,
        ...pageSettings,
    };
}
