{"version":3,"sources":["../../src/implementations.ts","../../src/crypto.ts","../../src/server.ts","../../src/index.ts"],"names":["createCookieFactory","createCookieSessionStorageFactory","createMemorySessionStorageFactory","createSessionStorageFactory","encoder","sign","value","secret","key","createKey","data","signature","hash","unsign","signed","index","byteStringToUint8Array","usages","byteString","array","i","createCookie","createCookieSessionStorage","createSessionStorage","createMemorySessionStorage","createRemixRequestHandler","originalErrorToString","createRequestHandler","build","mode","poweredByHeader","getLoadContext","handleRequest","request","method","url","context","startTime","response","getStorefrontHeaders","headers","createSession","defer","isCookie","isSession","json","MaxPartSizeExceededError","redirect","redirectDocument"],"mappings":"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","sourcesContent":["import {\n  createCookieFactory,\n  createCookieSessionStorageFactory,\n  createMemorySessionStorageFactory,\n  createSessionStorageFactory,\n} from '@remix-run/server-runtime';\n\nimport {sign, unsign} from './crypto';\n\nexport const createCookie = createCookieFactory({sign, unsign});\nexport const createCookieSessionStorage =\n  createCookieSessionStorageFactory(createCookie);\nexport const createSessionStorage = createSessionStorageFactory(createCookie);\nexport const createMemorySessionStorage =\n  createMemorySessionStorageFactory(createSessionStorage);\n","import type {SignFunction, UnsignFunction} from '@remix-run/server-runtime';\n\nconst encoder = new TextEncoder();\n\nexport const sign: SignFunction = async (value, secret) => {\n  const key = await createKey(secret, ['sign']);\n  const data = encoder.encode(value);\n  const signature = await crypto.subtle.sign('HMAC', key, data);\n  const hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(\n    /=+$/,\n    '',\n  );\n\n  return value + '.' + hash;\n};\n\nexport const unsign: UnsignFunction = async (signed, secret) => {\n  const index = signed.lastIndexOf('.');\n  const value = signed.slice(0, index);\n  const hash = signed.slice(index + 1);\n\n  const key = await createKey(secret, ['verify']);\n  const data = encoder.encode(value);\n  const signature = byteStringToUint8Array(atob(hash));\n  const valid = await crypto.subtle.verify('HMAC', key, signature, data);\n\n  return valid ? value : false;\n};\n\nasync function createKey(\n  secret: string,\n  usages: CryptoKey['usages'],\n): Promise<CryptoKey> {\n  const key = await crypto.subtle.importKey(\n    'raw',\n    encoder.encode(secret),\n    {name: 'HMAC', hash: 'SHA-256'},\n    false,\n    usages,\n  );\n\n  return key;\n}\n\nfunction byteStringToUint8Array(byteString: string): Uint8Array {\n  const array = new Uint8Array(byteString.length);\n\n  for (let i = 0; i < byteString.length; i++) {\n    array[i] = byteString.charCodeAt(i);\n  }\n\n  return array;\n}\n","/// <reference types=\"@shopify/hydrogen\" />\nimport {\n  createRequestHandler as createRemixRequestHandler,\n  type AppLoadContext,\n  type ServerBuild,\n} from '@remix-run/server-runtime';\nimport {createEventLogger} from './event-logger';\n\nconst originalErrorToString = Error.prototype.toString;\nError.prototype.toString = function () {\n  return this.stack || originalErrorToString.call(this);\n};\n\nexport function createRequestHandler<Context = unknown>({\n  build,\n  mode,\n  poweredByHeader = true,\n  getLoadContext,\n}: {\n  build: ServerBuild;\n  mode?: string;\n  poweredByHeader?: boolean;\n  getLoadContext?: (request: Request) => Promise<Context> | Context;\n}) {\n  const handleRequest = createRemixRequestHandler(build, mode);\n\n  return async (request: Request) => {\n    const method = request.method;\n\n    if ((method === 'GET' || method === 'HEAD') && request.body) {\n      return new Response(`${method} requests cannot have a body`, {\n        status: 400,\n      });\n    }\n\n    const url = new URL(request.url);\n\n    if (url.pathname.includes('//')) {\n      return new Response(null, {\n        status: 301,\n        headers: {\n          location: url.pathname.replace(/\\/+/g, '/'),\n        },\n      });\n    }\n\n    const context = getLoadContext\n      ? ((await getLoadContext(request)) as AppLoadContext)\n      : undefined;\n\n    if (process.env.NODE_ENV === 'development' && context) {\n      // Store logger in globalThis so it can be accessed from the worker.\n      // The global property must be different from the binding name,\n      // otherwise Miniflare throws an error when accessing it.\n      globalThis.__H2O_LOG_EVENT ??= createEventLogger(context);\n    }\n\n    const startTime = Date.now();\n\n    const response = await handleRequest(request, context);\n\n    if (poweredByHeader) {\n      response.headers.append('powered-by', 'Shopify, Hydrogen');\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      globalThis.__H2O_LOG_EVENT?.({\n        eventType: 'request',\n        url: request.url,\n        requestId: request.headers.get('request-id'),\n        purpose: request.headers.get('purpose'),\n        startTime,\n        responseInit: {\n          status: response.status,\n          statusText: response.statusText,\n          headers: Array.from(response.headers.entries()),\n        } satisfies ResponseInit,\n      });\n    }\n\n    return response;\n  };\n}\n\ntype StorefrontHeaders = {\n  requestGroupId: string | null;\n  buyerIp: string | null;\n  cookie: string | null;\n  purpose: string | null;\n};\n\nexport function getStorefrontHeaders(request: Request): StorefrontHeaders {\n  const headers = request.headers;\n  return {\n    requestGroupId: headers.get('request-id'),\n    buyerIp: headers.get('oxygen-buyer-ip'),\n    cookie: headers.get('cookie'),\n    purpose: headers.get('purpose'),\n  };\n}\n","export {\n  createCookie,\n  createCookieSessionStorage,\n  createMemorySessionStorage,\n  createSessionStorage,\n} from './implementations';\nexport {createRequestHandler, getStorefrontHeaders} from './server';\nexport type {\n  ActionFunction,\n  ActionFunctionArgs,\n  AppLoadContext,\n  Cookie,\n  CookieOptions,\n  CookieParseOptions,\n  CookieSerializeOptions,\n  CookieSignatureOptions,\n  DataFunctionArgs,\n  EntryContext,\n  ErrorResponse,\n  HandleDataRequestFunction,\n  HandleDocumentRequestFunction,\n  HandleErrorFunction,\n  HeadersArgs,\n  HeadersFunction,\n  HtmlLinkDescriptor,\n  JsonFunction,\n  LinkDescriptor,\n  LinksFunction,\n  LoaderFunction,\n  LoaderFunctionArgs,\n  MemoryUploadHandlerFilterArgs,\n  MemoryUploadHandlerOptions,\n  ServerRuntimeMetaArgs as MetaArgs,\n  ServerRuntimeMetaDescriptor as MetaDescriptor,\n  ServerRuntimeMetaFunction as MetaFunction,\n  PageLinkDescriptor,\n  RequestHandler,\n  SerializeFrom,\n  ServerBuild,\n  ServerEntryModule,\n  Session,\n  SessionData,\n  SessionIdStorageStrategy,\n  SessionStorage,\n  SignFunction,\n  TypedDeferredData,\n  TypedResponse,\n  UnsignFunction,\n  UploadHandler,\n  UploadHandlerPart,\n} from '@remix-run/server-runtime';\nexport {\n  createSession,\n  data,\n  defer,\n  isCookie,\n  isSession,\n  json,\n  MaxPartSizeExceededError,\n  redirect,\n  redirectDocument,\n} from '@remix-run/server-runtime';\n"]}