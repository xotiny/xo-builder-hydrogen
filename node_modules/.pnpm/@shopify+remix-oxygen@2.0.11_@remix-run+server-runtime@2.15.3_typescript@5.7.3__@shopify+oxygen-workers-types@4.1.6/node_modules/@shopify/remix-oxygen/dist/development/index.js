import { createCookieFactory, createCookieSessionStorageFactory, createSessionStorageFactory, createMemorySessionStorageFactory, createRequestHandler as createRequestHandler$1 } from '@remix-run/server-runtime';
export { MaxPartSizeExceededError, createSession, data, defer, isCookie, isSession, json, redirect, redirectDocument } from '@remix-run/server-runtime';

// src/implementations.ts

// src/crypto.ts
var encoder = new TextEncoder();
var sign = async (value, secret) => {
  const key = await createKey(secret, ["sign"]);
  const data2 = encoder.encode(value);
  const signature = await crypto.subtle.sign("HMAC", key, data2);
  const hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(
    /=+$/,
    ""
  );
  return value + "." + hash;
};
var unsign = async (signed, secret) => {
  const index = signed.lastIndexOf(".");
  const value = signed.slice(0, index);
  const hash = signed.slice(index + 1);
  const key = await createKey(secret, ["verify"]);
  const data2 = encoder.encode(value);
  const signature = byteStringToUint8Array(atob(hash));
  const valid = await crypto.subtle.verify("HMAC", key, signature, data2);
  return valid ? value : false;
};
async function createKey(secret, usages) {
  const key = await crypto.subtle.importKey(
    "raw",
    encoder.encode(secret),
    { name: "HMAC", hash: "SHA-256" },
    false,
    usages
  );
  return key;
}
function byteStringToUint8Array(byteString) {
  const array = new Uint8Array(byteString.length);
  for (let i = 0; i < byteString.length; i++) {
    array[i] = byteString.charCodeAt(i);
  }
  return array;
}

// src/implementations.ts
var createCookie = createCookieFactory({ sign, unsign });
var createCookieSessionStorage = createCookieSessionStorageFactory(createCookie);
var createSessionStorage = createSessionStorageFactory(createCookie);
var createMemorySessionStorage = createMemorySessionStorageFactory(createSessionStorage);

// src/event-logger.ts
var hasWarned = false;
function createEventLogger(appLoadContext) {
  const context = appLoadContext || {};
  const eventLoggerService = context?.env?.H2O_LOG_EVENT;
  if (typeof eventLoggerService?.fetch !== "function") return;
  return ({
    url,
    endTime = Date.now(),
    waitUntil = context?.waitUntil,
    ...rest
  }) => {
    const promise = Promise.resolve().then(
      () => eventLoggerService.fetch(
        new Request(url, {
          method: "POST",
          body: JSON.stringify({
            endTime,
            ...rest
          })
        })
      ).catch((error) => {
        if (!hasWarned) {
          console.debug("Failed to log H2O event\n", error.stack);
          hasWarned = true;
        }
      })
    );
    promise && waitUntil?.(promise);
  };
}

// src/server.ts
var originalErrorToString = Error.prototype.toString;
Error.prototype.toString = function() {
  return this.stack || originalErrorToString.call(this);
};
function createRequestHandler({
  build,
  mode,
  poweredByHeader = true,
  getLoadContext
}) {
  const handleRequest = createRequestHandler$1(build, mode);
  return async (request) => {
    const method = request.method;
    if ((method === "GET" || method === "HEAD") && request.body) {
      return new Response(`${method} requests cannot have a body`, {
        status: 400
      });
    }
    const url = new URL(request.url);
    if (url.pathname.includes("//")) {
      return new Response(null, {
        status: 301,
        headers: {
          location: url.pathname.replace(/\/+/g, "/")
        }
      });
    }
    const context = getLoadContext ? await getLoadContext(request) : void 0;
    if (context) {
      globalThis.__H2O_LOG_EVENT ??= createEventLogger(context);
    }
    const startTime = Date.now();
    const response = await handleRequest(request, context);
    if (poweredByHeader) {
      response.headers.append("powered-by", "Shopify, Hydrogen");
    }
    {
      globalThis.__H2O_LOG_EVENT?.({
        eventType: "request",
        url: request.url,
        requestId: request.headers.get("request-id"),
        purpose: request.headers.get("purpose"),
        startTime,
        responseInit: {
          status: response.status,
          statusText: response.statusText,
          headers: Array.from(response.headers.entries())
        }
      });
    }
    return response;
  };
}
function getStorefrontHeaders(request) {
  const headers = request.headers;
  return {
    requestGroupId: headers.get("request-id"),
    buyerIp: headers.get("oxygen-buyer-ip"),
    cookie: headers.get("cookie"),
    purpose: headers.get("purpose")
  };
}

export { createCookie, createCookieSessionStorage, createMemorySessionStorage, createRequestHandler, createSessionStorage, getStorefrontHeaders };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map