{"version":3,"sources":["../../src/implementations.ts","../../src/crypto.ts","../../src/server.ts","../../src/event-logger.ts","../../src/index.ts"],"names":["data"],"mappings":"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","sourcesContent":["import {\n  createCookieFactory,\n  createCookieSessionStorageFactory,\n  createMemorySessionStorageFactory,\n  createSessionStorageFactory,\n} from '@remix-run/server-runtime';\n\nimport {sign, unsign} from './crypto';\n\nexport const createCookie = createCookieFactory({sign, unsign});\nexport const createCookieSessionStorage =\n  createCookieSessionStorageFactory(createCookie);\nexport const createSessionStorage = createSessionStorageFactory(createCookie);\nexport const createMemorySessionStorage =\n  createMemorySessionStorageFactory(createSessionStorage);\n","import type {SignFunction, UnsignFunction} from '@remix-run/server-runtime';\n\nconst encoder = new TextEncoder();\n\nexport const sign: SignFunction = async (value, secret) => {\n  const key = await createKey(secret, ['sign']);\n  const data = encoder.encode(value);\n  const signature = await crypto.subtle.sign('HMAC', key, data);\n  const hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(\n    /=+$/,\n    '',\n  );\n\n  return value + '.' + hash;\n};\n\nexport const unsign: UnsignFunction = async (signed, secret) => {\n  const index = signed.lastIndexOf('.');\n  const value = signed.slice(0, index);\n  const hash = signed.slice(index + 1);\n\n  const key = await createKey(secret, ['verify']);\n  const data = encoder.encode(value);\n  const signature = byteStringToUint8Array(atob(hash));\n  const valid = await crypto.subtle.verify('HMAC', key, signature, data);\n\n  return valid ? value : false;\n};\n\nasync function createKey(\n  secret: string,\n  usages: CryptoKey['usages'],\n): Promise<CryptoKey> {\n  const key = await crypto.subtle.importKey(\n    'raw',\n    encoder.encode(secret),\n    {name: 'HMAC', hash: 'SHA-256'},\n    false,\n    usages,\n  );\n\n  return key;\n}\n\nfunction byteStringToUint8Array(byteString: string): Uint8Array {\n  const array = new Uint8Array(byteString.length);\n\n  for (let i = 0; i < byteString.length; i++) {\n    array[i] = byteString.charCodeAt(i);\n  }\n\n  return array;\n}\n","/// <reference types=\"@shopify/hydrogen\" />\nimport {\n  createRequestHandler as createRemixRequestHandler,\n  type AppLoadContext,\n  type ServerBuild,\n} from '@remix-run/server-runtime';\nimport {createEventLogger} from './event-logger';\n\nconst originalErrorToString = Error.prototype.toString;\nError.prototype.toString = function () {\n  return this.stack || originalErrorToString.call(this);\n};\n\nexport function createRequestHandler<Context = unknown>({\n  build,\n  mode,\n  poweredByHeader = true,\n  getLoadContext,\n}: {\n  build: ServerBuild;\n  mode?: string;\n  poweredByHeader?: boolean;\n  getLoadContext?: (request: Request) => Promise<Context> | Context;\n}) {\n  const handleRequest = createRemixRequestHandler(build, mode);\n\n  return async (request: Request) => {\n    const method = request.method;\n\n    if ((method === 'GET' || method === 'HEAD') && request.body) {\n      return new Response(`${method} requests cannot have a body`, {\n        status: 400,\n      });\n    }\n\n    const url = new URL(request.url);\n\n    if (url.pathname.includes('//')) {\n      return new Response(null, {\n        status: 301,\n        headers: {\n          location: url.pathname.replace(/\\/+/g, '/'),\n        },\n      });\n    }\n\n    const context = getLoadContext\n      ? ((await getLoadContext(request)) as AppLoadContext)\n      : undefined;\n\n    if (process.env.NODE_ENV === 'development' && context) {\n      // Store logger in globalThis so it can be accessed from the worker.\n      // The global property must be different from the binding name,\n      // otherwise Miniflare throws an error when accessing it.\n      globalThis.__H2O_LOG_EVENT ??= createEventLogger(context);\n    }\n\n    const startTime = Date.now();\n\n    const response = await handleRequest(request, context);\n\n    if (poweredByHeader) {\n      response.headers.append('powered-by', 'Shopify, Hydrogen');\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      globalThis.__H2O_LOG_EVENT?.({\n        eventType: 'request',\n        url: request.url,\n        requestId: request.headers.get('request-id'),\n        purpose: request.headers.get('purpose'),\n        startTime,\n        responseInit: {\n          status: response.status,\n          statusText: response.statusText,\n          headers: Array.from(response.headers.entries()),\n        } satisfies ResponseInit,\n      });\n    }\n\n    return response;\n  };\n}\n\ntype StorefrontHeaders = {\n  requestGroupId: string | null;\n  buyerIp: string | null;\n  cookie: string | null;\n  purpose: string | null;\n};\n\nexport function getStorefrontHeaders(request: Request): StorefrontHeaders {\n  const headers = request.headers;\n  return {\n    requestGroupId: headers.get('request-id'),\n    buyerIp: headers.get('oxygen-buyer-ip'),\n    cookie: headers.get('cookie'),\n    purpose: headers.get('purpose'),\n  };\n}\n","type H2OEvent = Parameters<NonNullable<typeof __H2O_LOG_EVENT>>[0];\n\nlet hasWarned = false;\n\n/**\n * @deprecated Only used with the classic Remix compiler\n */\nexport function createEventLogger(appLoadContext: Record<string, unknown>) {\n  const context = (appLoadContext || {}) as {\n    env?: Record<string, any>;\n    waitUntil?: (promise: Promise<any>) => void;\n  };\n\n  const eventLoggerService = context?.env?.H2O_LOG_EVENT as\n    | undefined\n    | {fetch: (req: Request) => Promise<Response>};\n\n  if (typeof eventLoggerService?.fetch !== 'function') return;\n\n  return ({\n    url,\n    endTime = Date.now(),\n    waitUntil = context?.waitUntil,\n    ...rest\n  }: H2OEvent) => {\n    const promise = Promise.resolve().then(() =>\n      eventLoggerService\n        .fetch(\n          new Request(url, {\n            method: 'POST',\n            body: JSON.stringify({\n              endTime,\n              ...rest,\n            }),\n          }),\n        )\n        .catch((error: Error) => {\n          if (!hasWarned) {\n            // This might repeat a lot of times due to\n            // the same issue, so we only warn once.\n            console.debug('Failed to log H2O event\\n', error.stack);\n            hasWarned = true;\n          }\n        }),\n    );\n\n    promise && waitUntil?.(promise);\n  };\n}\n","export {\n  createCookie,\n  createCookieSessionStorage,\n  createMemorySessionStorage,\n  createSessionStorage,\n} from './implementations';\nexport {createRequestHandler, getStorefrontHeaders} from './server';\nexport type {\n  ActionFunction,\n  ActionFunctionArgs,\n  AppLoadContext,\n  Cookie,\n  CookieOptions,\n  CookieParseOptions,\n  CookieSerializeOptions,\n  CookieSignatureOptions,\n  DataFunctionArgs,\n  EntryContext,\n  ErrorResponse,\n  HandleDataRequestFunction,\n  HandleDocumentRequestFunction,\n  HandleErrorFunction,\n  HeadersArgs,\n  HeadersFunction,\n  HtmlLinkDescriptor,\n  JsonFunction,\n  LinkDescriptor,\n  LinksFunction,\n  LoaderFunction,\n  LoaderFunctionArgs,\n  MemoryUploadHandlerFilterArgs,\n  MemoryUploadHandlerOptions,\n  ServerRuntimeMetaArgs as MetaArgs,\n  ServerRuntimeMetaDescriptor as MetaDescriptor,\n  ServerRuntimeMetaFunction as MetaFunction,\n  PageLinkDescriptor,\n  RequestHandler,\n  SerializeFrom,\n  ServerBuild,\n  ServerEntryModule,\n  Session,\n  SessionData,\n  SessionIdStorageStrategy,\n  SessionStorage,\n  SignFunction,\n  TypedDeferredData,\n  TypedResponse,\n  UnsignFunction,\n  UploadHandler,\n  UploadHandlerPart,\n} from '@remix-run/server-runtime';\nexport {\n  createSession,\n  data,\n  defer,\n  isCookie,\n  isSession,\n  json,\n  MaxPartSizeExceededError,\n  redirect,\n  redirectDocument,\n} from '@remix-run/server-runtime';\n"]}