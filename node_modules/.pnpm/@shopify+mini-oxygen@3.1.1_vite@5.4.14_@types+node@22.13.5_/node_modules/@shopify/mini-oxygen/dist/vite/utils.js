import path from "node:path";
import { Readable } from "node:stream";
import { Request } from "../worker/index.js";
function toURL(req = "/", origin) {
  const isRequest = typeof req !== "string";
  let pathname = (isRequest ? req.url : req) || "/";
  return new URL(
    (origin || isRequest && req.headers.host && `http://${req.headers.host}` || "http://example.com") + pathname
  );
}
function toWeb(req, headers) {
  if (!req.headers.host) {
    throw new Error("Request must contain a host header.");
  }
  return new Request(toURL(req), {
    method: req.method,
    headers: { ...headers, ...req.headers },
    body: req.headers["content-length"] ? Readable.toWeb(req) : void 0,
    duplex: "half",
    // This is required when sending a ReadableStream as body
    redirect: "manual"
    // Avoid consuming 300 responses here, return to browser
  });
}
function pipeFromWeb(webResponse, res) {
  const headers = Object.fromEntries(webResponse.headers.entries());
  const setCookieHeader = "set-cookie";
  if (headers[setCookieHeader]) {
    delete headers[setCookieHeader];
    res.setHeader(setCookieHeader, webResponse.headers.getSetCookie());
  }
  res.writeHead(webResponse.status, webResponse.statusText, headers);
  if (webResponse.body) {
    Readable.fromWeb(webResponse.body).pipe(res);
  } else {
    res.end();
  }
}
function getHmrUrl(viteDevServer) {
  const userHmrValue = viteDevServer.config.server?.hmr;
  if (userHmrValue === false) {
    console.warn(
      "HMR is disabled. Code changes will not be reflected in neither browser or server."
    );
    return "";
  }
  const configHmr = typeof userHmrValue === "object" ? userHmrValue : {};
  const hmrPort = configHmr.port;
  const hmrPath = configHmr.path;
  let hmrBase = viteDevServer.config.base;
  if (hmrPath) hmrBase = path.posix.join(hmrBase, hmrPath);
  return (hmrPort ? `http://localhost:${hmrPort}` : "") + hmrBase;
}
export {
  getHmrUrl,
  pipeFromWeb,
  toURL,
  toWeb
};
