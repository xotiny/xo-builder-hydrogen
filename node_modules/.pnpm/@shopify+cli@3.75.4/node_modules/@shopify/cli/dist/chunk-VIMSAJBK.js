import {
  platformAndArch
} from "./chunk-VTTVH23Q.js";
import {
  allAPIs,
  buildHeaders,
  shopifyFetch,
  z
} from "./chunk-O5UY3K6F.js";
import {
  cacheRetrieveOrRepopulate,
  getPackageManager,
  getSession,
  packageManagerFromUserAgent,
  removeSession,
  setSession
} from "./chunk-LH3QC4DP.js";
import {
  AbortError,
  BugError,
  Environment,
  FatalError,
  addPublicMetadata,
  addSensitiveMetadata,
  blockPartnersAccess,
  ciPlatform,
  cloudEnvironment,
  currentProcessIsGlobal,
  firstPartyDev,
  getIdentityTokenInformation,
  getPartnersToken,
  hashString,
  import_ts_error,
  isAppManagementDisabled,
  isCloudEnvironment,
  isSpin,
  isTTY,
  keypress,
  macAddress,
  nonRandomUUID,
  openURL,
  outputCompleted,
  outputContent,
  outputDebug,
  outputInfo,
  outputToken,
  serviceEnvironment,
  sessionConstants,
  spinFqdn,
  themeKitAccessDomain,
  themeToken
} from "./chunk-V4FD5VKG.js";
import {
  cwd
} from "./chunk-57Q6OQG4.js";
import {
  __commonJS,
  __require,
  __toESM,
  init_cjs_shims
} from "./chunk-PKR7KJ6P.js";

// ../../node_modules/.pnpm/network-interfaces@1.1.0/node_modules/network-interfaces/index.js
var require_network_interfaces = __commonJS({
  "../../node_modules/.pnpm/network-interfaces@1.1.0/node_modules/network-interfaces/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var os2 = __require("os");
    function isValid(address, options) {
      return !(typeof options.internal == "boolean" && address.internal !== options.internal || options.ipVersion === 4 && address.family !== "IPv4" || options.ipVersion === 6 && address.family !== "IPv6");
    }
    function findAddresses(interfaceName, options = {}) {
      let addresses = os2.networkInterfaces()[interfaceName];
      if (!addresses)
        throw new Error(`Network interface "${interfaceName}" does not exist`);
      let result = [];
      for (let address of addresses)
        isValid(address, options) && result.push(address);
      return result;
    }
    exports.toIp = function(interfaceName, options) {
      let addresses = findAddresses(interfaceName, options);
      if (addresses.length === 0)
        throw new Error(`No suitable IP address found on interface "${interfaceName}"`);
      return addresses[0].address;
    };
    exports.toIps = function(interfaceName, options) {
      return findAddresses(interfaceName, options).map((address) => address.address);
    };
    exports.fromIp = function(ip, options) {
      let interfaces = os2.networkInterfaces(), interfaceNames = Object.keys(interfaces);
      for (let interfaceName of interfaceNames)
        for (let address of interfaces[interfaceName])
          if (address.address === ip && isValid(address, options))
            return interfaceName;
      throw new Error(`No suitable interfaces were found with IP address "${ip}"`);
    };
    exports.getInterface = function(options) {
      let interfaces = os2.networkInterfaces(), interfaceNames = Object.keys(interfaces);
      for (let interfaceName of interfaceNames)
        if (findAddresses(interfaceName, options).length > 0)
          return interfaceName;
      throw new Error("No suitable interfaces were found");
    };
    exports.getInterfaces = function(options) {
      let interfaces = os2.networkInterfaces(), interfaceNames = Object.keys(interfaces), result = [];
      for (let interfaceName of interfaceNames)
        findAddresses(interfaceName, options).length > 0 && result.push(interfaceName);
      return result;
    };
  }
});

// ../cli-kit/dist/private/node/analytics.js
init_cjs_shims();

// ../cli-kit/dist/private/node/session.js
init_cjs_shims();

// ../cli-kit/dist/private/node/session/identity.js
init_cjs_shims();
function clientId() {
  let environment = serviceEnvironment();
  return environment === Environment.Local ? "e5380e02-312a-7408-5718-e07017e9cf52" : environment === Environment.Production ? "fbdb2649-e327-4907-8f67-908d24cfd7e3" : "e5380e02-312a-7408-5718-e07017e9cf52";
}
function applicationId(api) {
  switch (api) {
    case "admin": {
      let environment = serviceEnvironment();
      return environment === Environment.Local ? "e92482cebb9bfb9fb5a0199cc770fde3de6c8d16b798ee73e36c9d815e070e52" : environment === Environment.Production ? "7ee65a63608843c577db8b23c4d7316ea0a01bd2f7594f8a9c06ea668c1b775c" : "e92482cebb9bfb9fb5a0199cc770fde3de6c8d16b798ee73e36c9d815e070e52";
    }
    case "partners": {
      let environment = serviceEnvironment();
      return environment === Environment.Local ? "df89d73339ac3c6c5f0a98d9ca93260763e384d51d6038da129889c308973978" : environment === Environment.Production ? "271e16d403dfa18082ffb3d197bd2b5f4479c3fc32736d69296829cbb28d41a6" : "df89d73339ac3c6c5f0a98d9ca93260763e384d51d6038da129889c308973978";
    }
    case "storefront-renderer": {
      let environment = serviceEnvironment();
      return environment === Environment.Local ? "46f603de-894f-488d-9471-5b721280ff49" : environment === Environment.Production ? "ee139b3d-5861-4d45-b387-1bc3ada7811c" : "46f603de-894f-488d-9471-5b721280ff49";
    }
    case "business-platform": {
      let environment = serviceEnvironment();
      return environment === Environment.Local ? "ace6dc89-b526-456d-a942-4b8ef6acda4b" : environment === Environment.Production ? "32ff8ee5-82b8-4d93-9f8a-c6997cefb7dc" : "ace6dc89-b526-456d-a942-4b8ef6acda4b";
    }
    case "app-management":
      return serviceEnvironment() === Environment.Production ? "7ee65a63608843c577db8b23c4d7316ea0a01bd2f7594f8a9c06ea668c1b775c" : "e92482cebb9bfb9fb5a0199cc770fde3de6c8d16b798ee73e36c9d815e070e52";
    default:
      throw new BugError(`Application id for API of type: ${api}`);
  }
}

// ../cli-kit/dist/private/node/session/validate.js
init_cjs_shims();

// ../cli-kit/dist/private/node/session/schema.js
init_cjs_shims();
var DateSchema = z.preprocess((arg) => typeof arg == "string" || arg instanceof Date ? new Date(arg) : null, z.date()), IdentityTokenSchema = z.object({
  accessToken: z.string(),
  refreshToken: z.string(),
  expiresAt: DateSchema,
  scopes: z.array(z.string()),
  userId: z.string()
}), ApplicationTokenSchema = z.object({
  accessToken: z.string(),
  expiresAt: DateSchema,
  scopes: z.array(z.string())
}), SessionSchema = z.object({}).catchall(z.object({
  /**
   * It contains the identity token. Before usint it, we exchange it
   * to get a token that we can use with different applications. The exchanged
   * tokens for the applications are stored under applications.
   */
  identity: IdentityTokenSchema,
  /**
   * It contains exchanged tokens for the applications the CLI
   * authenticates with. Tokens are scoped under the fqdn of the applications.
   */
  applications: z.object({}).catchall(ApplicationTokenSchema)
}));
function validateCachedIdentityTokenStructure(identityToken) {
  return IdentityTokenSchema.safeParse(identityToken).success;
}

// ../cli-kit/dist/private/node/session/identity-token-validation.js
init_cjs_shims();

// ../cli-kit/dist/public/node/context/fqdn.js
init_cjs_shims();

// ../cli-kit/dist/public/node/vendor/dev_server/DevServer.js
init_cjs_shims();
var ni = __toESM(require_network_interfaces(), 1);
import fs from "fs";
import * as os from "os";
import { execSync } from "child_process";
var DevServerUtils = class _DevServerUtils {
  static assertConnectable(name, addr, port) {
    try {
      execSync(`nc -z -v -w 1 ${addr} ${port}`, {
        timeout: _DevServerUtils.CONNECT_TIMEOUT,
        stdio: "ignore"
      });
    } catch {
      throw new Error(`NET FAILED DevServer for '${name}' is not running on ${port} / ${addr}: \`dev up ${name}\` to start it.`);
    }
  }
  static inferenceModeAndProjectIsEdition2016(name) {
    try {
      fs.accessSync(_DevServerUtils.INFERENCE_MODE_SENTINEL);
      try {
        return fs.accessSync(`/opt/nginx/etc/manifest/${name}/current/edition-2024`), !1;
      } catch {
        return !0;
      }
    } catch {
      return !1;
    }
  }
  static getIpFromHosts(hostname) {
    try {
      let lines = fs.readFileSync(_DevServerUtils.HOSTS_FILE, "utf8").split(/\r?\n/);
      for (let line of lines) {
        let matches = /^\s*?([^#]+?)\s+([^#]+?)$/.exec(line);
        if (matches && matches.length === 3 && matches[2] === hostname)
          return matches[1];
      }
    } catch (error) {
      console.error("Error reading hosts file:", error);
    }
    throw new Error(`No IP found for hostname: ${hostname}`);
  }
  static getAddrPort2024(name) {
    try {
      let backendIp = _DevServerUtils.resolveBackendHost(name), interfaceName = ni.fromIp(backendIp, {
        internal: !0,
        ipVersion: 4
      });
      return [backendIp, _DevServerUtils.BACKEND_PORT];
    } catch {
      throw new Error(`DevServer for '${name}' is not running: \`dev up ${name}\` to start it.`);
    }
  }
  static getAddrPort2016(name) {
    try {
      let portContent = fs.readFileSync(`${os.homedir()}/.local/run/services/${name}/server/port`, "utf-8");
      return ["localhost", parseInt(portContent, 10)];
    } catch {
      throw new Error(`DevServer for '${name}' is not running: \`dev up ${name}\` to start it.`);
    }
  }
  static resolveBackendHost(name) {
    let host;
    try {
      host = fs.readlinkSync(`/opt/nginx/etc/manifest/${name}/current`);
    } catch {
      host = `${name}.root.shopify.dev.internal`;
    }
    try {
      return _DevServerUtils.getIpFromHosts(host);
    } catch {
      return host;
    }
  }
};
DevServerUtils.INFERENCE_MODE_SENTINEL = "/opt/dev/misc/dev-server-inference-mode";
DevServerUtils.BACKEND_PORT = 8080;
DevServerUtils.CONNECT_TIMEOUT = 100;
DevServerUtils.HOSTS_FILE = "/etc/hosts";
var DevServer = class {
  constructor(name) {
    if (!process.env.SPIN && !process.env.USING_DEV)
      throw new Error("DevServer is not supported in this environment");
    if (name === "shopify")
      throw new Error("Use DevServer.core for the 'shopify' project");
    this.name = name;
  }
  url({ nonstandardHostPrefix } = {}) {
    return `https://${this.host({ nonstandardHostPrefix })}`;
  }
  host({ nonstandardHostPrefix } = {}) {
    let prefix = nonstandardHostPrefix || this.name;
    if (process.env.SPIN === "1") {
      let services = fs.readdirSync("/run/ports2").filter((file) => file.endsWith(`--${this.name}`));
      if (services.length === 0)
        throw new Error(`DevServer for '${this.name}' not present in this spin environment`);
      let match = new RegExp(`^(.+)${this.name}$`).exec(services[0]), organization = match ? match[1] : "";
      return `${organization !== "shopify--" ? `${organization}` : ""}${this.name}.${process.env.SPIN_FQDN}`;
    } else return DevServerUtils.inferenceModeAndProjectIsEdition2016(this.name) ? (this.assertRunningLocally2016(), `${prefix}.myshopify.io`) : (this.assertRunningLocally2024(), `${prefix}.shop.dev`);
  }
  assertRunningLocally2024() {
    let [addr, port] = DevServerUtils.getAddrPort2024(this.name);
    DevServerUtils.assertConnectable(this.name, addr, port);
  }
  assertRunningLocally2016() {
    let [addr, port] = DevServerUtils.getAddrPort2016(this.name);
    DevServerUtils.assertConnectable(this.name, addr, port);
  }
}, DevServerCore = class {
  constructor() {
    this.name = "shopify";
  }
  url(prefix) {
    return `https://${this.host(prefix)}`;
  }
  host(prefix) {
    if (process.env.SPIN === "1") {
      if (!fs.readdirSync("/run/ports2").find((file) => file.endsWith(`--${this.name}`)))
        throw new Error(`DevServer for '${this.name}' not present in this spin environment`);
      return `${prefix}.${this.name}.${process.env.SPIN_FQDN}`;
    } else return DevServerUtils.inferenceModeAndProjectIsEdition2016("shopify") ? (this.assertRunningLocally2016(), `${prefix}.myshopify.io`) : (this.assertRunningLocally2024(), `${prefix}.my.shop.dev`);
  }
  assertRunningLocally2024() {
    let [addr, port] = DevServerUtils.getAddrPort2024("shopify");
    DevServerUtils.assertConnectable("shopify", addr, port);
  }
  assertRunningLocally2016() {
    let [addr, port] = DevServerUtils.getAddrPort2016("shopify");
    DevServerUtils.assertConnectable("shopify", addr, port);
  }
};

// ../cli-kit/dist/public/node/context/fqdn.js
var CouldntObtainPartnersSpinFQDNError = new AbortError("Couldn't obtain the Spin FQDN for Partners when the CLI is not running from a Spin environment."), CouldntObtainIdentitySpinFQDNError = new AbortError("Couldn't obtain the Spin FQDN for Identity when the CLI is not running from a Spin environment."), CouldntObtainShopifySpinFQDNError = new AbortError("Couldn't obtain the Spin FQDN for Shopify when the CLI is not running from a Spin environment."), NotProvidedStoreFQDNError = new AbortError("Couldn't obtain the Shopify FQDN because the store FQDN was not provided.");
async function partnersFqdn() {
  if (blockPartnersAccess())
    throw new BugError("Partners API is blocked by the SHOPIFY_CLI_NEVER_USE_PARTNERS_API environment variable.");
  let environment = serviceEnvironment(), productionFqdn = "partners.shopify.com";
  switch (environment) {
    case "local":
      return new DevServer("partners").host();
    case "spin":
      return `partners.${await spinFqdn()}`;
    default:
      return productionFqdn;
  }
}
async function appManagementFqdn() {
  let environment = serviceEnvironment(), productionFqdn = "app.shopify.com";
  switch (environment) {
    case "local":
      return new DevServerCore().host("app");
    case "spin":
      return `app.shopify.${await spinFqdn()}`;
    default:
      return productionFqdn;
  }
}
async function developerDashboardFqdn() {
  let environment = serviceEnvironment(), productionFqdn = "dev.shopify.com";
  switch (environment) {
    case "local":
      return new DevServerCore().host("dev");
    case "spin":
      return `dev.shopify.${await spinFqdn()}`;
    default:
      return productionFqdn;
  }
}
async function businessPlatformFqdn() {
  let environment = serviceEnvironment(), productionFqdn = "destinations.shopifysvc.com";
  switch (environment) {
    case "local":
      return new DevServer("business-platform").host();
    case "spin":
      return `business-platform.${await spinFqdn()}`;
    default:
      return productionFqdn;
  }
}
async function identityFqdn() {
  let environment = serviceEnvironment(), productionFqdn = "accounts.shopify.com";
  switch (environment) {
    case "local":
      return new DevServer("identity").host();
    case "spin":
      return `identity.${await spinFqdn()}`;
    default:
      return productionFqdn;
  }
}
async function normalizeStoreFqdn(store2) {
  let storeFqdn = store2.replace(/^https?:\/\//, "").replace(/\/$/, ""), addDomain = async (storeFqdn2) => {
    switch (serviceEnvironment()) {
      case "local":
        return new DevServerCore().host(storeFqdn2);
      case "spin":
        return `${storeFqdn2}.shopify.${await spinFqdn()}`;
      default:
        return `${storeFqdn2}.myshopify.com`;
    }
  };
  return ((storeFqdn2) => storeFqdn2.includes(".myshopify.com") || storeFqdn2.includes("spin.dev") || storeFqdn2.includes("shopify.io") || storeFqdn2.includes(".shop.dev"))(storeFqdn) ? storeFqdn : addDomain(storeFqdn);
}

// ../cli-kit/dist/public/node/result.js
init_cjs_shims();
var ok = (value) => new Ok(value), err = (err2) => new Err(err2), Ok = class {
  constructor(value) {
    this.value = value;
  }
  /**
   * Check if a `Result` is an `Err` inferring its type. `!isErr()` should be used before accessing the `value`
   *
   * @returns `false` as the `Resul` is `OK`
   */
  isErr() {
    return !1;
  }
  /**
   * Runs the `handler` method an return the same an unaltered copy of the `Result`. It could be used to log an
   * output when the result is `Ok` without breaking the flow
   *
   * @param handler - method to be run when the result is `Ok`
   * @returns a copy of the same `Result`
   */
  doOnOk(handler) {
    return handler(this.value), ok(this.value);
  }
  /**
   * A safe mode to throw the `error` of the `Result`
   */
  valueOrBug() {
    return this.value;
  }
  /**
   * Throws an abort error if the result doesn't represent a value.
   */
  valueOrAbort() {
    return this.value;
  }
  /**
   * Maps the value to another one with a different type. It leaves the `Error` type unaltered
   *
   * @param mapper - The mapper method to apply an `OK` value
   * @returns a new result with the new mapped value
   */
  map(mapper) {
    return ok(mapper(this.value));
  }
  /**
   * Maps the error type to another one. It leaves the `Ok` type and value unaltered
   *
   * @param _mapper - This mapper method is not used for an `Ok` value
   * @returns a new result with the new mapped error type and an value
   */
  mapError(_mapper) {
    return ok(this.value);
  }
}, Err = class {
  // eslint-disable-next-line node/handle-callback-err
  constructor(error) {
    this.error = error;
  }
  /**
   * Check if a `Result` is an `Err` inferring its type. `!isErr()` should be used before accessing the `value`
   *
   * @returns `false` as the `Resul` is `OK`
   */
  isErr() {
    return !0;
  }
  /**
   * Return an unaltered copy of the `Error` without doing anything.
   *
   * @param _handler - This handler method is not used for an `Error`
   * @returns a copy of the same `Error`
   */
  doOnOk(_handler) {
    return err(this.error);
  }
  /**
   * A safe mode to throw the `error` of the `Result`
   */
  valueOrBug() {
    throw this.error;
  }
  /**
   * Throws an abort error if the result doesn't represent a value.
   */
  valueOrAbort() {
    if (this.error instanceof FatalError)
      throw this.error;
    if (this.error instanceof import_ts_error.ExtendableError || this.error instanceof Error) {
      let error = new AbortError(this.error.message);
      throw error.stack = this.error.stack, error;
    } else
      throw new AbortError(`${this.error}`);
  }
  /**
   * Maps the value type to another one. It leaves the `Error` unaltered
   *
   * @param _mapper - This mapper method is not used for an `Error` value
   * @returns a new result with the new value type and an unaltered error
   */
  map(_mapper) {
    return err(this.error);
  }
  /**
   * Maps the error to another one with a different type. It leaves the value type unaltered
   *
   * @param mapper - The mapper method to apply an `Error` value
   * @returns a new result with the new mapped error
   */
  mapError(mapper) {
    return err(mapper(this.error));
  }
};

// ../cli-kit/dist/private/node/session/identity-token-validation.js
async function validateIdentityToken(token) {
  if (isSpin() && firstPartyDev())
    return !0;
  try {
    return withIntrospectionURL(async (introspectionURL) => {
      let options = {
        method: "POST",
        headers: { Authorization: `Bearer ${token}`, "Content-Type": "application/json" },
        body: JSON.stringify({ token })
      };
      outputDebug(`Sending Identity Introspection request to URL: ${introspectionURL}`);
      let response = await shopifyFetch(introspectionURL, options);
      if (response.ok && response.headers.get("content-type")?.includes("json")) {
        let json = await response.json();
        return outputDebug(`The identity token is valid: ${json.valid}`), ok(json.valid);
      } else {
        if (response.status === 404 || response.status > 500)
          return err(new AbortError(`The introspection endpoint returned a ${response.status}: ${introspectionURL}`));
        {
          let text = await response.text();
          return outputDebug(`The Introspection request failed with:
 - status: ${response.status}
 - www-authenticate header: ${JSON.stringify(response.headers.get("www-authenticate"))}
 - body: ${JSON.stringify(text)}`), ok(!1);
        }
      }
    });
  } catch (error) {
    return outputDebug(`The identity token is invalid: ${error}`), !1;
  }
}
async function withIntrospectionURL(fn) {
  let cacheKey = `identity-introspection-url-${await identityFqdn()}`, introspectionURL = await cacheRetrieveOrRepopulate(cacheKey, getIntrospectionURL, 6048e5), result = await fn(introspectionURL);
  if (result.isErr() && (introspectionURL = await cacheRetrieveOrRepopulate(cacheKey, getIntrospectionURL, 0), result = await fn(introspectionURL)), result.isErr())
    throw result.error;
  return result.value;
}
async function getIntrospectionURL() {
  return (await (await shopifyFetch(`https://${await identityFqdn()}/.well-known/openid-configuration.json`)).json()).introspection_endpoint;
}

// ../cli-kit/dist/private/node/session/validate.js
function validateScopes(requestedScopes, identity) {
  let currentScopes = identity.scopes;
  return firstPartyDev() !== currentScopes.includes("employee") ? !1 : requestedScopes.every((scope) => currentScopes.includes(scope));
}
async function validateSession(scopes, applications, session) {
  if (!session || !validateScopes(scopes, session.identity))
    return "needs_full_auth";
  let tokensAreExpired = isTokenExpired(session.identity);
  if (applications.partnersApi) {
    let appId = applicationId("partners"), token = session.applications[appId];
    tokensAreExpired = tokensAreExpired || isTokenExpired(token);
  }
  if (applications.appManagementApi) {
    let appId = applicationId("app-management"), token = session.applications[appId];
    tokensAreExpired = tokensAreExpired || isTokenExpired(token);
  }
  if (applications.storefrontRendererApi) {
    let appId = applicationId("storefront-renderer"), token = session.applications[appId];
    tokensAreExpired = tokensAreExpired || isTokenExpired(token);
  }
  if (applications.adminApi) {
    let appId = applicationId("admin"), realAppId = `${applications.adminApi.storeFqdn}-${appId}`, token = session.applications[realAppId];
    tokensAreExpired = tokensAreExpired || isTokenExpired(token);
  }
  if (outputDebug(`- Token validation -> It's expired: ${tokensAreExpired}`), !validateCachedIdentityTokenStructure(session.identity))
    return "needs_full_auth";
  if (tokensAreExpired)
    return "needs_refresh";
  let identityIsValid = await validateIdentityToken(session.identity.accessToken);
  return outputDebug(`- Token validation -> It's invalid in identity: ${!identityIsValid}`), identityIsValid ? "ok" : "needs_full_auth";
}
function isTokenExpired(token) {
  return token ? token.expiresAt < expireThreshold() : !0;
}
function expireThreshold() {
  return new Date(Date.now() + sessionConstants.expirationTimeMarginInMinutes * 60 * 1e3);
}

// ../cli-kit/dist/private/node/session/scopes.js
init_cjs_shims();
function allDefaultScopes(extraScopes = []) {
  let scopes = allAPIs.map((api) => defaultApiScopes(api)).flat();
  return scopes = ["openid", ...scopes, ...extraScopes].map(scopeTransform), Array.from(new Set(scopes));
}
function apiScopes(api, extraScopes = []) {
  let scopes = [...defaultApiScopes(api), ...extraScopes.map(scopeTransform)].map(scopeTransform);
  return Array.from(new Set(scopes));
}
function defaultApiScopes(api) {
  switch (api) {
    case "admin":
      return ["graphql", "themes", "collaborator"];
    case "storefront-renderer":
      return ["devtools"];
    case "partners":
      return ["cli"];
    case "business-platform":
      return ["destinations", "store-management"];
    case "app-management":
      return ["app-management"];
    default:
      throw new BugError(`Unknown API: ${api}`);
  }
}
function scopeTransform(scope) {
  switch (scope) {
    case "graphql":
      return "https://api.shopify.com/auth/shop.admin.graphql";
    case "themes":
      return "https://api.shopify.com/auth/shop.admin.themes";
    case "collaborator":
      return "https://api.shopify.com/auth/partners.collaborator-relationships.readonly";
    case "cli":
      return "https://api.shopify.com/auth/partners.app.cli.access";
    case "devtools":
      return "https://api.shopify.com/auth/shop.storefront-renderer.devtools";
    case "destinations":
      return "https://api.shopify.com/auth/destinations.readonly";
    case "store-management":
      return "https://api.shopify.com/auth/organization.store-management";
    case "app-management":
      return "https://api.shopify.com/auth/organization.apps.manage";
    default:
      return scope;
  }
}

// ../cli-kit/dist/private/node/session/exchange.js
init_cjs_shims();

// ../../node_modules/.pnpm/jose@5.9.6/node_modules/jose/dist/node/esm/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/jose@5.9.6/node_modules/jose/dist/node/esm/runtime/base64url.js
init_cjs_shims();
import { Buffer } from "node:buffer";

// ../../node_modules/.pnpm/jose@5.9.6/node_modules/jose/dist/node/esm/lib/buffer_utils.js
init_cjs_shims();
var encoder = new TextEncoder(), decoder = new TextDecoder(), MAX_INT32 = 2 ** 32;

// ../../node_modules/.pnpm/jose@5.9.6/node_modules/jose/dist/node/esm/runtime/base64url.js
function normalize(input) {
  let encoded = input;
  return encoded instanceof Uint8Array && (encoded = decoder.decode(encoded)), encoded;
}
var decode = (input) => new Uint8Array(Buffer.from(normalize(input), "base64url"));

// ../../node_modules/.pnpm/jose@5.9.6/node_modules/jose/dist/node/esm/util/errors.js
init_cjs_shims();
var JOSEError = class extends Error {
  static code = "ERR_JOSE_GENERIC";
  code = "ERR_JOSE_GENERIC";
  constructor(message, options) {
    super(message, options), this.name = this.constructor.name, Error.captureStackTrace?.(this, this.constructor);
  }
};
var JWTInvalid = class extends JOSEError {
  static code = "ERR_JWT_INVALID";
  code = "ERR_JWT_INVALID";
};

// ../../node_modules/.pnpm/jose@5.9.6/node_modules/jose/dist/node/esm/lib/is_object.js
init_cjs_shims();
function isObjectLike(value) {
  return typeof value == "object" && value !== null;
}
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]")
    return !1;
  if (Object.getPrototypeOf(input) === null)
    return !0;
  let proto = input;
  for (; Object.getPrototypeOf(proto) !== null; )
    proto = Object.getPrototypeOf(proto);
  return Object.getPrototypeOf(input) === proto;
}

// ../../node_modules/.pnpm/jose@5.9.6/node_modules/jose/dist/node/esm/util/base64url.js
init_cjs_shims();
var decode2 = decode;

// ../../node_modules/.pnpm/jose@5.9.6/node_modules/jose/dist/node/esm/util/decode_jwt.js
init_cjs_shims();
function decodeJwt(jwt) {
  if (typeof jwt != "string")
    throw new JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");
  let { 1: payload, length } = jwt.split(".");
  if (length === 5)
    throw new JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");
  if (length !== 3)
    throw new JWTInvalid("Invalid JWT");
  if (!payload)
    throw new JWTInvalid("JWTs must contain a payload");
  let decoded;
  try {
    decoded = decode2(payload);
  } catch {
    throw new JWTInvalid("Failed to base64url decode the payload");
  }
  let result;
  try {
    result = JSON.parse(decoder.decode(decoded));
  } catch {
    throw new JWTInvalid("Failed to parse the decoded payload as JSON");
  }
  if (!isObject(result))
    throw new JWTInvalid("Invalid JWT Claims Set");
  return result;
}

// ../cli-kit/dist/private/node/session/exchange.js
var InvalidGrantError = class extends import_ts_error.ExtendableError {
}, InvalidRequestError = class extends import_ts_error.ExtendableError {
}, InvalidTargetError = class extends AbortError {
};
async function exchangeAccessForApplicationTokens(identityToken, scopes, store2) {
  let token = identityToken.accessToken, [partners, storefront, businessPlatform, admin, appManagement] = await Promise.all([
    requestAppToken("partners", token, scopes.partners),
    requestAppToken("storefront-renderer", token, scopes.storefront),
    requestAppToken("business-platform", token, scopes.businessPlatform),
    store2 ? requestAppToken("admin", token, scopes.admin, store2) : {},
    isAppManagementDisabled() ? {} : requestAppToken("app-management", token, scopes.appManagement)
  ]);
  return {
    ...partners,
    ...storefront,
    ...businessPlatform,
    ...admin,
    ...appManagement
  };
}
async function refreshAccessToken(currentToken) {
  let clientId2 = clientId(), params = {
    grant_type: "refresh_token",
    access_token: currentToken.accessToken,
    refresh_token: currentToken.refreshToken,
    client_id: clientId2
  }, value = (await tokenRequest(params)).mapError(tokenRequestErrorHandler).valueOrBug();
  return buildIdentityToken(value, currentToken.userId);
}
async function exchangeCustomPartnerToken(token) {
  let appId = applicationId("partners");
  try {
    let accessToken = (await requestAppToken("partners", token, ["https://api.shopify.com/auth/partners.app.cli.access"]))[appId].accessToken, userId2 = nonRandomUUID(token);
    return setLastSeenUserIdAfterAuth(userId2), setLastSeenAuthMethod("partners_token"), { accessToken, userId: userId2 };
  } catch {
    throw new AbortError("The custom token provided is invalid.", "Ensure the token is correct and not expired.");
  }
}
async function exchangeDeviceCodeForAccessToken(deviceCode) {
  let clientId2 = await clientId(), tokenResult = await tokenRequest({
    grant_type: "urn:ietf:params:oauth:grant-type:device_code",
    device_code: deviceCode,
    client_id: clientId2
  });
  if (tokenResult.isErr())
    return err(tokenResult.error);
  let identityToken = buildIdentityToken(tokenResult.value);
  return ok(identityToken);
}
async function requestAppToken(api, token, scopes = [], store2) {
  let appId = applicationId(api), params = {
    grant_type: "urn:ietf:params:oauth:grant-type:token-exchange",
    requested_token_type: "urn:ietf:params:oauth:token-type:access_token",
    subject_token_type: "urn:ietf:params:oauth:token-type:access_token",
    client_id: await clientId(),
    audience: appId,
    scope: scopes.join(" "),
    subject_token: token,
    ...api === "admin" && { destination: `https://${store2}/admin` }
  }, identifier = appId;
  api === "admin" && store2 && (identifier = `${store2}-${appId}`);
  let value = (await tokenRequest(params)).mapError(tokenRequestErrorHandler).valueOrBug(), appToken = buildApplicationToken(value);
  return { [identifier]: appToken };
}
function tokenRequestErrorHandler(error) {
  let invalidTargetErrorMessage = `You are not authorized to use the CLI to develop in the provided store.

You can't use Shopify CLI with development stores if you only have Partner staff member access. If you want to use Shopify CLI to work on a development store, then you should be the store owner or create a staff account on the store.

If you're the store owner, then you need to log in to the store directly using the store URL at least once before you log in using Shopify CLI.Logging in to the Shopify admin directly connects the development store with your Shopify login.`;
  return error === "invalid_grant" ? new InvalidGrantError() : error === "invalid_request" ? new InvalidRequestError() : error === "invalid_target" ? new InvalidTargetError(invalidTargetErrorMessage) : new AbortError(error);
}
async function tokenRequest(params) {
  let fqdn = await identityFqdn(), url = new URL(`https://${fqdn}/oauth/token`);
  url.search = new URLSearchParams(Object.entries(params)).toString();
  let res = await shopifyFetch(url.href, { method: "POST" }), payload = await res.json();
  return res.ok ? ok(payload) : err(payload.error);
}
function buildIdentityToken(result, existingUserId) {
  let userId2 = existingUserId ?? (result.id_token ? decodeJwt(result.id_token).sub : void 0);
  if (!userId2)
    throw new BugError("Error setting userId for session. No id_token or pre-existing user ID provided.");
  return {
    accessToken: result.access_token,
    refreshToken: result.refresh_token,
    expiresAt: new Date(Date.now() + result.expires_in * 1e3),
    scopes: result.scope.split(" "),
    userId: userId2
  };
}
function buildApplicationToken(result) {
  return {
    accessToken: result.access_token,
    expiresAt: new Date(Date.now() + result.expires_in * 1e3),
    scopes: result.scope.split(" ")
  };
}

// ../cli-kit/dist/private/node/session/store.js
init_cjs_shims();
async function store(session) {
  let jsonSession = JSON.stringify(session);
  setSession(jsonSession);
}
async function fetch() {
  let content = getSession();
  if (!content)
    return;
  let contentJson = JSON.parse(content), parsedSession = await SessionSchema.safeParseAsync(contentJson);
  if (parsedSession.success)
    return parsedSession.data;
  await remove();
}
async function remove() {
  removeSession();
}

// ../cli-kit/dist/private/node/session/device-authorization.js
init_cjs_shims();
async function requestDeviceAuthorization(scopes) {
  let fqdn = await identityFqdn(), queryParams = { client_id: clientId(), scope: scopes.join(" ") }, url = `https://${fqdn}/oauth/device_authorization`, jsonResult = await (await shopifyFetch(url, {
    method: "POST",
    headers: { "Content-type": "application/x-www-form-urlencoded" },
    body: convertRequestToParams(queryParams)
  })).json();
  if (outputDebug(outputContent`Received device authorization code: ${outputToken.json(jsonResult)}`), !jsonResult.device_code || !jsonResult.verification_uri_complete)
    throw new BugError("Failed to start authorization process");
  if (outputInfo(`
To run this command, log in to Shopify.`), !isTTY())
    throw new AbortError("Authorization is required to continue, but the current environment does not support interactive prompts.", "To resolve this, specify credentials in your environment, or run the command in an interactive environment such as your local terminal.");
  outputInfo(outputContent`User verification code: ${jsonResult.user_code}`);
  let linkToken = outputToken.link(jsonResult.verification_uri_complete);
  return isCloudEnvironment() ? outputInfo(outputContent`👉 Open this link to start the auth process: ${linkToken}`) : (outputInfo("\u{1F449} Press any key to open the login page on your browser"), await keypress(), await openURL(jsonResult.verification_uri_complete), outputInfo(outputContent`Opened link to start the auth process: ${linkToken}`)), {
    deviceCode: jsonResult.device_code,
    userCode: jsonResult.user_code,
    verificationUri: jsonResult.verification_uri,
    expiresIn: jsonResult.expires_in,
    verificationUriComplete: jsonResult.verification_uri_complete,
    interval: jsonResult.interval
  };
}
async function pollForDeviceAuthorization(code, interval = 5) {
  let currentIntervalInSeconds = interval;
  return new Promise((resolve, reject) => {
    let onPoll = async () => {
      let result = await exchangeDeviceCodeForAccessToken(code);
      if (!result.isErr()) {
        resolve(result.value);
        return;
      }
      let error = result.error ?? "unknown_failure";
      switch (outputDebug(outputContent`Polling for device authorization... status: ${error}`), error) {
        case "authorization_pending": {
          startPolling();
          return;
        }
        case "slow_down":
          currentIntervalInSeconds += 5;
          {
            startPolling();
            return;
          }
        case "access_denied":
        case "expired_token":
        case "unknown_failure":
          reject(result);
      }
    }, startPolling = () => {
      setTimeout(onPoll, currentIntervalInSeconds * 1e3);
    };
    startPolling();
  });
}
function convertRequestToParams(queryParams) {
  return Object.entries(queryParams).map(([key, value]) => value && `${key}=${value}`).filter((hasValue) => !!hasValue).join("&");
}

// ../cli-kit/dist/private/node/api/rest.js
init_cjs_shims();
function restRequestBody(requestBody) {
  if (requestBody)
    return JSON.stringify(requestBody);
}
function restRequestUrl(session, apiVersion, path, searchParams = {}) {
  let url = new URL(isThemeAccessSession(session) ? `https://${themeKitAccessDomain}/cli/admin/api/${apiVersion}${path}.json` : `https://${session.storeFqdn}/admin/api/${apiVersion}${path}.json`);
  return Object.entries(searchParams).forEach(([name, value]) => {
    url.searchParams.set(name, value);
  }), url.toString();
}
function restRequestHeaders(session) {
  let store2 = session.storeFqdn, token = session.token, headers = buildHeaders(session.token);
  return isThemeAccessSession(session) && (headers["X-Shopify-Shop"] = store2, headers["X-Shopify-Access-Token"] = token), headers;
}
function isThemeAccessSession(session) {
  return session.token.startsWith("shptka_");
}

// ../cli-kit/dist/private/node/session.js
var userId, authMethod = "none";
async function getLastSeenUserIdAfterAuth() {
  if (userId)
    return userId;
  let currentSession = await fetch() || {}, fqdn = await identityFqdn(), cachedUserId = currentSession[fqdn]?.identity.userId;
  if (cachedUserId)
    return cachedUserId;
  let customToken = getPartnersToken() ?? themeToken();
  return customToken ? nonRandomUUID(customToken) : "unknown";
}
function setLastSeenUserIdAfterAuth(id) {
  userId = id;
}
async function getLastSeenAuthMethod() {
  if (authMethod !== "none")
    return authMethod;
  let currentSession = await fetch() || {}, fqdn = await identityFqdn();
  if (currentSession[fqdn]?.identity.userId)
    return "device_auth";
  if (getPartnersToken())
    return "partners_token";
  let themePassword = themeToken();
  return themePassword ? isThemeAccessSession({ token: themePassword, storeFqdn: "" }) ? "theme_access_token" : "custom_app_token" : "none";
}
function setLastSeenAuthMethod(method) {
  authMethod = method;
}
async function ensureAuthenticated(applications, _env, { forceRefresh = !1, noPrompt = !1 } = {}) {
  let fqdn = await identityFqdn(), previousStoreFqdn = applications.adminApi?.storeFqdn;
  if (previousStoreFqdn) {
    let normalizedStoreName = await normalizeStoreFqdn(previousStoreFqdn);
    previousStoreFqdn === applications.adminApi?.storeFqdn && (applications.adminApi.storeFqdn = normalizedStoreName);
  }
  let currentSession = await fetch() || {}, fqdnSession = currentSession[fqdn], scopes = getFlattenScopes(applications);
  outputDebug(outputContent`Validating existing session against the scopes:
${outputToken.json(scopes)}
For applications:
${outputToken.json(applications)}
`);
  let validationResult = await validateSession(scopes, applications, fqdnSession), newSession = {};
  function throwOnNoPrompt() {
    if (!(!noPrompt || isSpin() && firstPartyDev()))
      throw new AbortError(`The currently available CLI credentials are invalid.

The CLI is currently unable to prompt for reauthentication.`, "Restart the CLI process you were running. If in an interactive terminal, you will be prompted to reauthenticate. If in a non-interactive terminal, ensure the correct credentials are available in the program environment.");
  }
  if (validationResult === "needs_full_auth")
    throwOnNoPrompt(), outputDebug(outputContent`Initiating the full authentication flow...`), newSession = await executeCompleteFlow(applications, fqdn);
  else if (validationResult === "needs_refresh" || forceRefresh) {
    outputDebug(outputContent`The current session is valid but needs refresh. Refreshing...`);
    try {
      newSession = await refreshTokens(fqdnSession.identity, applications, fqdn);
    } catch (error) {
      if (error instanceof InvalidGrantError)
        throwOnNoPrompt(), newSession = await executeCompleteFlow(applications, fqdn);
      else throw error instanceof InvalidRequestError ? (await remove(), new AbortError(`
Error validating auth session`, "We've cleared the current session, please try again")) : error;
    }
  }
  let completeSession = { ...currentSession, ...newSession };
  Object.keys(newSession).length > 0 && await store(completeSession);
  let tokens = await tokensFor(applications, completeSession, fqdn), envToken = getPartnersToken();
  return envToken && applications.partnersApi && (tokens.partners = (await exchangeCustomPartnerToken(envToken)).accessToken), setLastSeenAuthMethod(envToken ? "partners_token" : "device_auth"), setLastSeenUserIdAfterAuth(tokens.userId), tokens;
}
async function executeCompleteFlow(applications, identityFqdn2) {
  let scopes = getFlattenScopes(applications), exchangeScopes = getExchangeScopes(applications), store2 = applications.adminApi?.storeFqdn;
  firstPartyDev() && (outputDebug(outputContent`Authenticating as Shopify Employee...`), scopes.push("employee"));
  let identityToken, identityTokenInformation = getIdentityTokenInformation();
  if (identityTokenInformation)
    identityToken = buildIdentityTokenFromEnv(scopes, identityTokenInformation);
  else {
    outputDebug(outputContent`Requesting device authorization code...`);
    let deviceAuth = await requestDeviceAuthorization(scopes);
    outputDebug(outputContent`Starting polling for the identity token...`), identityToken = await pollForDeviceAuthorization(deviceAuth.deviceCode, deviceAuth.interval);
  }
  outputDebug(outputContent`CLI token received. Exchanging it for application tokens...`);
  let result = await exchangeAccessForApplicationTokens(identityToken, exchangeScopes, store2), session = {
    [identityFqdn2]: {
      identity: identityToken,
      applications: result
    }
  };
  return outputCompleted("Logged in."), session;
}
async function refreshTokens(token, applications, fqdn) {
  let identityToken = await refreshAccessToken(token), exchangeScopes = getExchangeScopes(applications), applicationTokens = await exchangeAccessForApplicationTokens(identityToken, exchangeScopes, applications.adminApi?.storeFqdn);
  return {
    [fqdn]: {
      identity: identityToken,
      applications: applicationTokens
    }
  };
}
async function tokensFor(applications, session, fqdn) {
  let fqdnSession = session[fqdn];
  if (!fqdnSession)
    throw new BugError("No session found after ensuring authenticated");
  let tokens = {
    userId: fqdnSession.identity.userId
  };
  if (applications.adminApi) {
    let appId = applicationId("admin"), realAppId = `${applications.adminApi.storeFqdn}-${appId}`, token = fqdnSession.applications[realAppId]?.accessToken;
    token && (tokens.admin = { token, storeFqdn: applications.adminApi.storeFqdn });
  }
  if (applications.partnersApi) {
    let appId = applicationId("partners");
    tokens.partners = fqdnSession.applications[appId]?.accessToken;
  }
  if (applications.storefrontRendererApi) {
    let appId = applicationId("storefront-renderer");
    tokens.storefront = fqdnSession.applications[appId]?.accessToken;
  }
  if (applications.businessPlatformApi) {
    let appId = applicationId("business-platform");
    tokens.businessPlatform = fqdnSession.applications[appId]?.accessToken;
  }
  if (applications.appManagementApi) {
    let appId = applicationId("app-management");
    tokens.appManagement = fqdnSession.applications[appId]?.accessToken;
  }
  return tokens;
}
function getFlattenScopes(apps) {
  let admin = apps.adminApi?.scopes || [], partner = apps.partnersApi?.scopes || [], storefront = apps.storefrontRendererApi?.scopes || [], businessPlatform = apps.businessPlatformApi?.scopes || [], appManagement = apps.appManagementApi?.scopes || [], requestedScopes = [...admin, ...partner, ...storefront, ...businessPlatform, ...appManagement];
  return allDefaultScopes(requestedScopes);
}
function getExchangeScopes(apps) {
  let adminScope = apps.adminApi?.scopes || [], partnerScope = apps.partnersApi?.scopes || [], storefrontScopes = apps.storefrontRendererApi?.scopes || [], businessPlatformScopes = apps.businessPlatformApi?.scopes || [], appManagementScopes = apps.appManagementApi?.scopes || [];
  return {
    admin: apiScopes("admin", adminScope),
    partners: apiScopes("partners", partnerScope),
    storefront: apiScopes("storefront-renderer", storefrontScopes),
    businessPlatform: apiScopes("business-platform", businessPlatformScopes),
    appManagement: apiScopes("app-management", appManagementScopes)
  };
}
function buildIdentityTokenFromEnv(scopes, identityTokenInformation) {
  return {
    ...identityTokenInformation,
    expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3),
    scopes
  };
}

// ../cli-kit/dist/private/node/analytics.js
async function startAnalytics({ commandContent, args, currentTime = (/* @__PURE__ */ new Date()).getTime(), commandClass }) {
  let startCommand = commandContent.command;
  commandClass && Object.prototype.hasOwnProperty.call(commandClass, "analyticsNameOverride") && (startCommand = commandClass.analyticsNameOverride() ?? commandContent.command);
  let pluginName = commandClass?.plugin?.name;
  commandClass && "customPluginName" in commandClass && (pluginName = commandClass.customPluginName), await addSensitiveMetadata(() => ({
    commandStartOptions: {
      startTime: currentTime,
      startCommand,
      startArgs: args
    }
  })), await addPublicMetadata(() => ({
    cmd_all_launcher: packageManagerFromUserAgent(),
    cmd_all_alias_used: commandContent.alias,
    cmd_all_topic: commandContent.topic,
    cmd_all_plugin: pluginName,
    cmd_all_force: flagIncluded("force", commandClass) ? args.includes("--force") : void 0
  }));
}
async function getEnvironmentData(config) {
  let ciplatform = ciPlatform(), pluginNames = getPluginNames(config), shopifyPlugins = pluginNames.filter((plugin) => plugin.startsWith("@shopify/")), { platform, arch } = platformAndArch();
  return {
    uname: `${platform} ${arch}`,
    env_ci: ciplatform.isCI,
    env_ci_platform: ciplatform.name,
    env_plugin_installed_any_custom: pluginNames.length !== shopifyPlugins.length,
    env_plugin_installed_shopify: JSON.stringify(shopifyPlugins),
    env_shell: config.shell,
    env_web_ide: cloudEnvironment().editor ? cloudEnvironment().platform : void 0,
    env_device_id: hashString(await macAddress()),
    env_cloud: cloudEnvironment().platform,
    env_package_manager: await getPackageManager(cwd()),
    env_is_global: currentProcessIsGlobal(),
    env_auth_method: await getLastSeenAuthMethod()
  };
}
async function getSensitiveEnvironmentData(config) {
  return {
    env_plugin_installed_all: JSON.stringify(getPluginNames(config))
  };
}
function getPluginNames(config) {
  return [...config.plugins.keys()].sort().filter((plugin) => !plugin.startsWith("@oclif/"));
}
function flagIncluded(flag, commandClass) {
  if (!commandClass)
    return !1;
  let commandFlags = commandClass.flags ?? {};
  return Object.keys(commandFlags).includes(flag);
}

export {
  partnersFqdn,
  appManagementFqdn,
  developerDashboardFqdn,
  businessPlatformFqdn,
  normalizeStoreFqdn,
  ok,
  err,
  exchangeCustomPartnerToken,
  remove,
  restRequestBody,
  restRequestUrl,
  restRequestHeaders,
  isThemeAccessSession,
  getLastSeenUserIdAfterAuth,
  setLastSeenUserIdAfterAuth,
  setLastSeenAuthMethod,
  ensureAuthenticated,
  startAnalytics,
  getEnvironmentData,
  getSensitiveEnvironmentData
};
//# sourceMappingURL=chunk-VIMSAJBK.js.map
