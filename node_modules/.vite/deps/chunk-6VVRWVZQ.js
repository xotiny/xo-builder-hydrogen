import {
  CONFIG
} from "./chunk-SSTWVKXD.js";

// node_modules/.pnpm/@xotiny+xb-react-elements@1.1.7_@remix-run+react@2.15.3_react-dom@18.3.1_react@18.3.1__react@_de3647dslfchm23rzktcfpukke/node_modules/@xotiny/xb-react-elements/dist/utils/get-collection-filter/index.js
function getSortValuesFromParam(sortParam, handle) {
  switch (sortParam) {
    case "price-high-low":
      return {
        sortKey: "PRICE",
        reverse: true
      };
    case "price-low-high":
      return {
        sortKey: "PRICE",
        reverse: false
      };
    case "best-selling":
      return {
        sortKey: "BEST_SELLING",
        reverse: false
      };
    case "newest":
      return handle === "all" ? {
        sortKey: "CREATED_AT",
        reverse: true
      } : {
        sortKey: "CREATED",
        reverse: true
      };
    case "created-descending":
      return handle === "all" ? {
        sortKey: "CREATED_AT",
        reverse: true
      } : {
        sortKey: "CREATED",
        reverse: true
      };
    case "oldest":
      return handle === "all" ? {
        sortKey: "CREATED_AT",
        reverse: false
      } : {
        sortKey: "CREATED",
        reverse: false
      };
    case "created-ascending":
      return handle === "all" ? {
        sortKey: "CREATED_AT",
        reverse: false
      } : {
        sortKey: "CREATED",
        reverse: false
      };
    case "title-ascending":
      return {
        sortKey: "TITLE",
        reverse: false
      };
    case "title-descending":
      return {
        sortKey: "TITLE",
        reverse: true
      };
    case "featured":
      return handle === "all" ? {
        sortKey: "ID",
        reverse: false
      } : {
        sortKey: "MANUAL",
        reverse: false
      };
    default:
      return {
        sortKey: "RELEVANCE",
        reverse: false
      };
  }
}
function parseAsCurrency(value, locale) {
  return new Intl.NumberFormat(locale.language + "-" + locale.country, {
    style: "currency",
    currency: locale.currency
  }).format(value);
}
function getAppliedFilter(filters, allFilterValues, locale) {
  return filters.map((filter) => {
    var _a, _b;
    const foundValue = allFilterValues == null ? void 0 : allFilterValues.find((value) => {
      const valueInput = JSON.parse(value.input);
      if (valueInput.price && filter.price) {
        return true;
      }
      return (
        // This comparison should be okay as long as we're not manipulating the input we
        // get from the API before using it as a URL param.
        JSON.stringify(valueInput) === JSON.stringify(filter)
      );
    });
    if (!foundValue) {
      console.error("Could not find filter value for filter", filter);
      return null;
    }
    if (foundValue.id === "filter.v.price") {
      const input = JSON.parse(foundValue.input);
      const min = parseAsCurrency(((_a = input.price) == null ? void 0 : _a.min) ?? 0, locale);
      const max = ((_b = input.price) == null ? void 0 : _b.max) ? parseAsCurrency(input.price.max, locale) : "";
      const label = min && max ? `${min} - ${max}` : "Price";
      return {
        filter,
        label
      };
    }
    return {
      filter,
      label: foundValue.label
    };
  }).filter((filter) => filter !== null);
}
function getAppliedFilterLink(filter, params, location) {
  const paramsClone = new URLSearchParams(params);
  Object.entries(filter.filter).forEach(([key, value]) => {
    const fullKey = CONFIG.collectionPage.filterUrlPrefix + key;
    paramsClone.delete(fullKey, JSON.stringify(value));
  });
  return `${location.pathname}?${paramsClone.toString()}`;
}
function filterInputToParams(rawInput, params) {
  const input = typeof rawInput === "string" ? JSON.parse(rawInput) : rawInput;
  Object.entries(input).forEach(([key, value]) => {
    if (key === "price") {
      params.set(`${CONFIG.collectionPage.filterUrlPrefix}${key}`, JSON.stringify(value));
    } else {
      if (params.has(`${CONFIG.collectionPage.filterUrlPrefix}${key}`, JSON.stringify(value))) {
        params.delete(`${CONFIG.collectionPage.filterUrlPrefix}${key}`, JSON.stringify(value));
      } else {
        params.append(`${CONFIG.collectionPage.filterUrlPrefix}${key}`, JSON.stringify(value));
      }
    }
  });
  return params;
}
function getFilterLink(rawInput, params, location) {
  const paramsClone = new URLSearchParams(params);
  const newParams = filterInputToParams(rawInput, paramsClone);
  return `${location.pathname}?${newParams.toString()}`;
}

export {
  getSortValuesFromParam,
  getAppliedFilter,
  getAppliedFilterLink,
  filterInputToParams,
  getFilterLink
};
//# sourceMappingURL=chunk-6VVRWVZQ.js.map
